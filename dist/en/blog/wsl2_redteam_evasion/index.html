<!DOCTYPE html><html lang="en"> <head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1"><meta name="color-scheme" content="dark"><link rel="preconnect" href="https://fonts.googleapis.com"><link rel="preconnect" href="https://fonts.gstatic.com" crossorigin><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=JetBrains+Mono:wght@300;400;500&display=swap"><link rel="icon" href="/favicon.svg"><link rel="canonical" href="https://maindavis.github.io/en/blog/wsl2_redteam_evasion/"><title>Red Team with WSL2: Network Monitoring Blind Spot | MainDavis Red Team</title><meta name="title" content="Red Team with WSL2: Network Monitoring Blind Spot | MainDavis Red Team"><meta name="description" content="How a Red Teamer can abuse Hyper-V communication channels (AF_VSOCK) for unmonitored communication and Cross-OS lateral movement."><!-- Open Graph / Facebook --><meta property="og:type" content="article"><meta property="og:url" content="https://maindavis.github.io/en/blog/wsl2_redteam_evasion/"><meta property="og:title" content="Red Team with WSL2: Network Monitoring Blind Spot | MainDavis Red Team"><meta property="og:description" content="How a Red Teamer can abuse Hyper-V communication channels (AF_VSOCK) for unmonitored communication and Cross-OS lateral movement."><meta property="og:image" content="https://maindavis.github.io/open-graph/en/wsl2_redteam_evasion.png"><meta property="og:image:width" content="1200"><meta property="og:image:height" content="630"><!-- Twitter --><meta property="twitter:card" content="summary_large_image"><meta property="twitter:url" content="https://maindavis.github.io/en/blog/wsl2_redteam_evasion/"><meta property="twitter:title" content="Red Team with WSL2: Network Monitoring Blind Spot | MainDavis Red Team"><meta property="twitter:description" content="How a Red Teamer can abuse Hyper-V communication channels (AF_VSOCK) for unmonitored communication and Cross-OS lateral movement."><meta property="twitter:image" content="https://maindavis.github.io/open-graph/en/wsl2_redteam_evasion.png"><link rel="stylesheet" href="/_astro/about.B9y4o1ar.css">
<link rel="stylesheet" href="/_astro/index.BcZbEljn.css"></head> <body class="min-h-screen"> <style>astro-island,astro-slot,astro-static-slot{display:contents}</style><script>(()=>{var l=(o,t)=>{let i=async()=>{await(await o())()},e=typeof t.value=="object"?t.value:void 0,s={timeout:e==null?void 0:e.timeout};"requestIdleCallback"in window?window.requestIdleCallback(i,s):setTimeout(i,s.timeout||200)};(self.Astro||(self.Astro={})).idle=l;window.dispatchEvent(new Event("astro:idle"));})();;(()=>{var A=Object.defineProperty;var g=(i,o,a)=>o in i?A(i,o,{enumerable:!0,configurable:!0,writable:!0,value:a}):i[o]=a;var d=(i,o,a)=>g(i,typeof o!="symbol"?o+"":o,a);{let i={0:t=>m(t),1:t=>a(t),2:t=>new RegExp(t),3:t=>new Date(t),4:t=>new Map(a(t)),5:t=>new Set(a(t)),6:t=>BigInt(t),7:t=>new URL(t),8:t=>new Uint8Array(t),9:t=>new Uint16Array(t),10:t=>new Uint32Array(t),11:t=>1/0*t},o=t=>{let[l,e]=t;return l in i?i[l](e):void 0},a=t=>t.map(o),m=t=>typeof t!="object"||t===null?t:Object.fromEntries(Object.entries(t).map(([l,e])=>[l,o(e)]));class y extends HTMLElement{constructor(){super(...arguments);d(this,"Component");d(this,"hydrator");d(this,"hydrate",async()=>{var b;if(!this.hydrator||!this.isConnected)return;let e=(b=this.parentElement)==null?void 0:b.closest("astro-island[ssr]");if(e){e.addEventListener("astro:hydrate",this.hydrate,{once:!0});return}let c=this.querySelectorAll("astro-slot"),n={},h=this.querySelectorAll("template[data-astro-template]");for(let r of h){let s=r.closest(this.tagName);s!=null&&s.isSameNode(this)&&(n[r.getAttribute("data-astro-template")||"default"]=r.innerHTML,r.remove())}for(let r of c){let s=r.closest(this.tagName);s!=null&&s.isSameNode(this)&&(n[r.getAttribute("name")||"default"]=r.innerHTML)}let p;try{p=this.hasAttribute("props")?m(JSON.parse(this.getAttribute("props"))):{}}catch(r){let s=this.getAttribute("component-url")||"<unknown>",v=this.getAttribute("component-export");throw v&&(s+=` (export ${v})`),console.error(`[hydrate] Error parsing props for component ${s}`,this.getAttribute("props"),r),r}let u;await this.hydrator(this)(this.Component,p,n,{client:this.getAttribute("client")}),this.removeAttribute("ssr"),this.dispatchEvent(new CustomEvent("astro:hydrate"))});d(this,"unmount",()=>{this.isConnected||this.dispatchEvent(new CustomEvent("astro:unmount"))})}disconnectedCallback(){document.removeEventListener("astro:after-swap",this.unmount),document.addEventListener("astro:after-swap",this.unmount,{once:!0})}connectedCallback(){if(!this.hasAttribute("await-children")||document.readyState==="interactive"||document.readyState==="complete")this.childrenConnectedCallback();else{let e=()=>{document.removeEventListener("DOMContentLoaded",e),c.disconnect(),this.childrenConnectedCallback()},c=new MutationObserver(()=>{var n;((n=this.lastChild)==null?void 0:n.nodeType)===Node.COMMENT_NODE&&this.lastChild.nodeValue==="astro:end"&&(this.lastChild.remove(),e())});c.observe(this,{childList:!0}),document.addEventListener("DOMContentLoaded",e)}}async childrenConnectedCallback(){let e=this.getAttribute("before-hydration-url");e&&await import(e),this.start()}async start(){let e=JSON.parse(this.getAttribute("opts")),c=this.getAttribute("client");if(Astro[c]===void 0){window.addEventListener(`astro:${c}`,()=>this.start(),{once:!0});return}try{await Astro[c](async()=>{let n=this.getAttribute("renderer-url"),[h,{default:p}]=await Promise.all([import(this.getAttribute("component-url")),n?import(n):()=>()=>{}]),u=this.getAttribute("component-export")||"default";if(!u.includes("."))this.Component=h[u];else{this.Component=h;for(let f of u.split("."))this.Component=this.Component[f]}return this.hydrator=p,this.hydrate},e,this)}catch(n){console.error(`[astro-island] Error hydrating ${this.getAttribute("component-url")}`,n)}}attributeChangedCallback(){this.hydrate()}}d(y,"observedAttributes",["props"]),customElements.get("astro-island")||customElements.define("astro-island",y)}})();</script><astro-island uid="Z2c8VbI" prefix="r0" component-url="/_astro/MatrixRain.TxUs3SNa.js" component-export="default" renderer-url="/_astro/client.BuOr9PT5.js" props="{}" ssr="" client="idle" opts="{&quot;name&quot;:&quot;MatrixRain&quot;,&quot;value&quot;:true}" await-children=""><canvas class="pointer-events-none fixed inset-0 z-0 opacity-40" aria-hidden="true"></canvas><!--astro:end--></astro-island> <astro-island uid="Z1upAD6" prefix="r1" component-url="/_astro/SearchModal.BgunQDqN.js" component-export="default" renderer-url="/_astro/client.BuOr9PT5.js" props="{&quot;locale&quot;:[0,&quot;en&quot;]}" ssr="" client="idle" opts="{&quot;name&quot;:&quot;SearchModal&quot;,&quot;value&quot;:true}"></astro-island> <div class="relative z-10 flex min-h-screen flex-col"> <header class="border-b border-terminal-border bg-terminal-black/90"> <div class="mx-auto flex max-w-6xl flex-col gap-3 px-4 py-4 md:flex-row md:items-center md:justify-between md:px-8"> <div class="flex items-center gap-3 text-xs uppercase tracking-[0.3em] text-terminal-muted/80"> <span class="h-2 w-2 rounded-full bg-terminal-green shadow-glow"></span> SESSION_ACTIVE :: RED_TEAM_ENGAGEMENT </div> <div class="flex flex-wrap items-center gap-3"> <nav class="flex gap-2 text-sm"> <a href="/en" class="rounded-sm border px-3 py-1 transition border-terminal-border text-terminal-muted hover:border-terminal-green hover:shadow-glow-strong"> ~/home </a><a href="/en/blog" class="rounded-sm border px-3 py-1 transition border-terminal-green text-terminal-green text-glow"> ~/blog </a><a href="/en/arsenal" class="rounded-sm border px-3 py-1 transition border-terminal-border text-terminal-muted hover:border-terminal-green hover:shadow-glow-strong"> ~/arsenal </a><a href="/en/about" class="rounded-sm border px-3 py-1 transition border-terminal-border text-terminal-muted hover:border-terminal-green hover:shadow-glow-strong"> ~/about </a> </nav> <a href="/es/blog/wsl2_redteam_evasion" class="rounded-sm border border-terminal-border px-3 py-1 text-xs uppercase tracking-[0.25em] text-terminal-muted transition hover:border-terminal-green hover:text-terminal-green"> ES </a> </div> </div> </header> <main class="flex-1 px-4 pb-12 pt-6 md:px-8">  <section class="mx-auto w-full max-w-5xl"> <div class="panel border-glow rounded-md px-5 py-4"> <h1 class="text-xl text-terminal-green text-glow">Red Team with WSL2: Network Monitoring Blind Spot</h1> <p class="mt-2 text-sm text-terminal-cyan/80">How a Red Teamer can abuse Hyper-V communication channels (AF_VSOCK) for unmonitored communication and Cross-OS lateral movement.</p> </div> <div class="mt-6">  <div class="post-hero border border-terminal-border/70 rounded-md"> <img src="/images/blog/wsl2_evasion.png" alt="Red Team with WSL2: Network Monitoring Blind Spot" loading="eager" decoding="async" fetchpriority="high"> </div> <article class="panel border-glow mt-6 rounded-md px-5 py-5 text-sm leading-relaxed text-terminal-light/90"> <p>The challenge of operating stealthily in Windows “User Land” has reached a saturation point. Hooks in <code>ntdll</code>, ETW (Event Tracing for Windows) monitoring, and NDIS filters in the network stack make moving or executing code increasingly noisy.</p>
<p>But what if I told you there is a direct tunnel to the Windows kernel that most security solutions completely ignore? Welcome to <strong>WSL2</strong> and the world of <strong>Hyper-V Sockets (AF_VSOCK)</strong>.</p>
<h2 id="the-paradigm-shift-decoupling-and-shadow-instances">The Paradigm Shift: Decoupling and “Shadow Instances”</h2>
<p>Traditionally, we treat WSL (Windows Subsystem for Linux) as a simple tool. But for a Red Teamer, it is a <strong>“Shadow Instance”</strong>: a full operating system sharing the hardware but not the Host’s security oversight.</p>
<p>It is vital to clarify a common myth: <strong>WSL2 does not make you invisible to the corporate perimeter firewall</strong>. Traffic leaving Linux towards the internet (e.g., your C2) still passes through the <code>vEthernet</code> interface and finally the physical NIC, being visible to a Palo Alto or BlueCoat.</p>
<p>The real advantage is <strong>Correlation Decoupling</strong>. Although traffic exits via the physical NIC and is visible to the firewall, the source process is a Linux binary (e.g., <code>curl</code> or a custom ELF), <strong>not a Windows process</strong>.
This breaks the typical correlation chain that looks for “Windows Process X making Connection Y”. The firewall sees the traffic, but the host monitoring tools don’t see which Windows process generated it (because a Windows process didn’t generate it).</p>
<h2 id="staring-into-the-abyss-low-level-architecture">Staring into the Abyss: Low-Level Architecture</h2>
<p>To understand the true invisibility of this technique, we must dissect the WSL2 architecture beyond the surface.</p>
<h3 id="1-the-privilege-hierarchy-rings">1. The Privilege Hierarchy (Rings)</h3>
<p>On a modern Windows machine with VBS (Virtualization-based Security) enabled:</p>
<ul>
<li><strong>Ring 3 (User Mode)</strong>: Where your applications and security agents live.</li>
<li><strong>Ring 0 (Kernel Mode)</strong>: The realm of drivers, the NT kernel, and security callbacks feeding telemetry.</li>
<li><strong>Ring -1 (Hypervisor)</strong>: Hyper-V reigns here. It is the most privileged level.</li>
</ul>
<p>WSL2 is not a containerized process; it is a <strong>Lightweight Utility VM</strong>. Linux runs its own kernel parallel to the Windows kernel. When we use <code>AF_VSOCK</code>, communication is facilitated by the Hypervisor via <strong>shared memory channels</strong> and signaling mechanisms, rather than a traditional virtualized network.</p>
<h3 id="2-vmbus-the-memory-highway">2. VMBus: The Memory Highway</h3>
<p>The <strong>VMBus</strong> is a logical transport mechanism between Hyper-V partitions. It is not a network; it is a shared memory channel based on Ring Buffers.</p>
<ul>
<li><strong>In Linux (Guest)</strong>: The <code>hv_sock</code> driver (<code>drivers/hv/hv_sock.c</code>) exposes the <code>AF_VSOCK</code> address family. Writing to the socket copies data directly to the VMBus Ring Buffer.</li>
<li><strong>In Windows (Host)</strong>: The <code>hvsock.sys</code> driver (Kernel Mode) picks up this data from the VMBus and delivers it to the service or process listening on <code>AF_HYPERV</code>.</li>
</ul>
<h3 id="3-the-blind-spot-ndis-and-wfp">3. The Blind Spot: NDIS and WFP</h3>
<p>Most network monitoring solutions in Windows (Personal Firewalls, sensors with network inspection) anchor themselves at two points:</p>
<ol>
<li><strong>NDIS (Network Driver Interface Specification)</strong>: Filters for physical or virtual network drivers (<code>vEthernet</code>).</li>
<li><strong>WFP (Windows Filtering Platform)</strong>: Callouts to inspect TCP/IP, UDP packets, etc.</li>
</ol>
<p><strong>AF_VSOCK traffic is never encapsulated in an IP packet</strong>. It has no Ethernet headers, no IP, no TCP. It is a raw Byte Stream flowing from memory to memory managed by the Hypervisor.
As a result, the traffic <strong>passes underneath</strong> NDIS and WFP filters. For a solution monitoring the network stack, this communication simply <em>does not exist</em>.</p>
<p>The addressing scheme is simple and alien to IP:</p>
<ul>
<li><strong>CID (Context Identifier)</strong>: <code>CID_HOST (2)</code> is our backdoor to the Windows Host.</li>
<li><strong>Puerto</strong>: A 32-bit integer.</li>
</ul>
<h2 id="weaponizing-virtualization">Weaponizing Virtualization</h2>
<p>This is where the <strong>Cross-OS</strong> attack comes in. This technique shines in <strong>Post-Exploitation</strong> scenarios: you have already compromised the “Shadow Instance” (Linux) or the Host, and are looking for persistence or stealthy lateral movement.
If we control Linux, we can pump arbitrary data into the Host. We just need a user to execute (or inject) a small “Receiver” on Windows that listens on the socket.</p>
<h3 id="traveler-the-proof-of-concept">Traveler: The Proof of Concept</h3>
<p>To demonstrate this, I developed <strong>Traveler</strong> (source code available in the repo), a tool designed to inject shellcode from WSL2 directly into Windows memory.</p>
<p>The attack architecture is as follows:</p>
<ol>
<li><strong>Leymano (Sender - Linux)</strong>: Encrypts the payload (shellcode) and sends it via an <code>AF_VSOCK</code> socket to CID 2.</li>
<li><strong>Anchor (Receiver - Windows)</strong>: Listens on <code>AF_HYPERV</code> (Windows’ implementation of vsock), receives the stream, decrypts it in memory, and executes it.</li>
</ol>
<p>The brilliance of this scheme is not the execution itself, but the <strong>transport</strong>. The payload never touches the disk on Windows (avoiding static AV scans) and never travels over the network (avoiding corporate IDS/IPS).</p>
<h2 id="show-me-the-code-nim">Show me the Code (Nim)</h2>
<p>Implementing this is surprisingly simple thanks to modern languages like Nim, which allows us to interact with the Windows API and Linux syscalls with ease.</p>
<h3 id="the-host-side-windows">The Host Side (Windows)</h3>
<p>On Windows, we need to manually define the <code>SOCKADDR_HV</code> structure, as it’s not standard in all headers. Note the <code>VmId</code> and <code>ServiceId</code>.</p>
<pre class="astro-code github-dark" style="background-color:#24292e;color:#e1e4e8; overflow-x: auto;" tabindex="0" data-language="nim"><code><span class="line"><span style="color:#F97583">import</span><span style="color:#E1E4E8"> winim</span><span style="color:#F97583">/</span><span style="color:#E1E4E8">lean</span></span>
<span class="line"></span>
<span class="line"><span style="color:#6A737D"># Definition of the structure for Hyper-V Sockets</span></span>
<span class="line"><span style="color:#F97583">type</span><span style="color:#79B8FF"> SOCKADDR_HV</span><span style="color:#E1E4E8"> {.pure, final.} </span><span style="color:#F97583">=</span><span style="color:#F97583"> object</span></span>
<span class="line"><span style="color:#79B8FF">  Family</span><span style="color:#F97583">*:</span><span style="color:#79B8FF"> USHORT</span></span>
<span class="line"><span style="color:#79B8FF">  Reserved</span><span style="color:#F97583">*:</span><span style="color:#79B8FF"> USHORT</span></span>
<span class="line"><span style="color:#79B8FF">  VmId</span><span style="color:#F97583">*:</span><span style="color:#79B8FF"> GUID</span><span style="color:#6A737D">      # VM ID (or Host ID)</span></span>
<span class="line"><span style="color:#79B8FF">  ServiceId</span><span style="color:#F97583">*:</span><span style="color:#79B8FF"> GUID</span><span style="color:#6A737D"> # Service ID (similar to port)</span></span>
<span class="line"></span>
<span class="line"><span style="color:#6A737D"># Template for the VSOCK GUID</span></span>
<span class="line"><span style="color:#6A737D"># Notice how the port is embedded in the first dword of the GUID</span></span>
<span class="line"><span style="color:#F97583">proc</span><span style="color:#B392F0"> makeServiceGUID</span><span style="color:#E1E4E8">(port</span><span style="color:#F97583">:</span><span style="color:#F97583"> uint32</span><span style="color:#E1E4E8">)</span><span style="color:#F97583">:</span><span style="color:#79B8FF"> GUID</span><span style="color:#F97583"> =</span></span>
<span class="line"><span style="color:#E1E4E8">  result </span><span style="color:#F97583">=</span><span style="color:#79B8FF"> GUID</span><span style="color:#E1E4E8">(</span><span style="color:#79B8FF">Data1</span><span style="color:#F97583">:</span><span style="color:#E1E4E8"> port</span><span style="color:#F97583">.int32</span><span style="color:#E1E4E8">, </span><span style="color:#79B8FF">Data2</span><span style="color:#F97583">:</span><span style="color:#79B8FF"> 0xfacb</span><span style="color:#E1E4E8">, </span><span style="color:#79B8FF">Data3</span><span style="color:#F97583">:</span><span style="color:#79B8FF"> 0x11e6</span><span style="color:#E1E4E8">, </span></span>
<span class="line"><span style="color:#79B8FF">                Data4</span><span style="color:#F97583">:</span><span style="color:#E1E4E8"> [</span><span style="color:#79B8FF">0xbd</span><span style="color:#F97583">.byte</span><span style="color:#E1E4E8">, </span><span style="color:#79B8FF">0x58</span><span style="color:#E1E4E8">, </span><span style="color:#79B8FF">0x64</span><span style="color:#E1E4E8">, </span><span style="color:#79B8FF">0x00</span><span style="color:#E1E4E8">, </span><span style="color:#79B8FF">0x6a</span><span style="color:#E1E4E8">, </span><span style="color:#79B8FF">0x79</span><span style="color:#E1E4E8">, </span><span style="color:#79B8FF">0x86</span><span style="color:#E1E4E8">, </span><span style="color:#79B8FF">0xd3</span><span style="color:#E1E4E8">])</span></span>
<span class="line"></span></code></pre>
<p>To listen, we simply create a socket with the <code>AF_HYPERV</code> (34) family:</p>
<pre class="astro-code github-dark" style="background-color:#24292e;color:#e1e4e8; overflow-x: auto;" tabindex="0" data-language="nim"><code><span class="line"><span style="color:#F97583">var</span><span style="color:#E1E4E8"> s </span><span style="color:#F97583">=</span><span style="color:#79B8FF"> socket</span><span style="color:#E1E4E8">(</span><span style="color:#79B8FF">34</span><span style="color:#E1E4E8">, </span><span style="color:#79B8FF">SOCK_STREAM</span><span style="color:#E1E4E8">, </span><span style="color:#79B8FF">1</span><span style="color:#E1E4E8">) </span><span style="color:#6A737D"># AF_HYPERV, 1 = HV_PROTOCOL_RAW</span></span>
<span class="line"><span style="color:#F97583">bind</span><span style="color:#E1E4E8">(s, </span><span style="color:#F97583">...</span><span style="color:#E1E4E8">)</span></span>
<span class="line"><span style="color:#79B8FF">listen</span><span style="color:#E1E4E8">(s, </span><span style="color:#79B8FF">1</span><span style="color:#E1E4E8">)</span></span>
<span class="line"></span></code></pre>
<h3 id="the-guest-side-linux">The Guest Side (Linux)</h3>
<p>From Linux, connection is trivial. We use the standard <code>AF_VSOCK</code> (40) family and point to <code>CID_HOST</code> (2).</p>
<pre class="astro-code github-dark" style="background-color:#24292e;color:#e1e4e8; overflow-x: auto;" tabindex="0" data-language="nim"><code><span class="line"><span style="color:#F97583">import</span><span style="color:#E1E4E8"> posix</span></span>
<span class="line"></span>
<span class="line"><span style="color:#F97583">const</span></span>
<span class="line"><span style="color:#79B8FF">  AF_VSOCK</span><span style="color:#F97583"> =</span><span style="color:#79B8FF"> 40</span></span>
<span class="line"><span style="color:#79B8FF">  VMADDR_CID_HOST</span><span style="color:#F97583"> =</span><span style="color:#79B8FF"> 2</span></span>
<span class="line"><span style="color:#79B8FF">  TARGET_PORT</span><span style="color:#F97583"> =</span><span style="color:#79B8FF"> 5005</span></span>
<span class="line"></span>
<span class="line"><span style="color:#F97583">var</span><span style="color:#E1E4E8"> fd </span><span style="color:#F97583">=</span><span style="color:#79B8FF"> socket</span><span style="color:#E1E4E8">(</span><span style="color:#79B8FF">AF_VSOCK</span><span style="color:#E1E4E8">, </span><span style="color:#79B8FF">SOCK_STREAM</span><span style="color:#E1E4E8">, </span><span style="color:#79B8FF">0</span><span style="color:#E1E4E8">)</span></span>
<span class="line"></span>
<span class="line"><span style="color:#F97583">var</span><span style="color:#E1E4E8"> addr_vm</span><span style="color:#F97583">:</span><span style="color:#79B8FF"> SockAddr_VM</span></span>
<span class="line"><span style="color:#E1E4E8">addr_vm</span><span style="color:#F97583">.</span><span style="color:#E1E4E8">svm_family </span><span style="color:#F97583">=</span><span style="color:#79B8FF"> AF_VSOCK</span></span>
<span class="line"><span style="color:#E1E4E8">addr_vm</span><span style="color:#F97583">.</span><span style="color:#E1E4E8">svm_port </span><span style="color:#F97583">=</span><span style="color:#79B8FF"> TARGET_PORT</span></span>
<span class="line"><span style="color:#E1E4E8">addr_vm</span><span style="color:#F97583">.</span><span style="color:#E1E4E8">svm_cid </span><span style="color:#F97583">=</span><span style="color:#79B8FF"> VMADDR_CID_HOST</span></span>
<span class="line"></span>
<span class="line"><span style="color:#6A737D"># Connecting directly to the Windows kernel...</span></span>
<span class="line"><span style="color:#79B8FF">connect</span><span style="color:#E1E4E8">(fd, addr_vm, </span><span style="color:#F97583">...</span><span style="color:#E1E4E8">)</span></span>
<span class="line"><span style="color:#79B8FF">send</span><span style="color:#E1E4E8">(fd, payload, </span><span style="color:#F97583">...</span><span style="color:#E1E4E8">)</span></span>
<span class="line"></span></code></pre>
<h2 id="conclusion-the-hidden-attack-surface">Conclusion: The Hidden Attack Surface</h2>
<p>WSL2 has brought Linux to the Windows desktop, but it has also brought new communication primitives that are not yet fully mature from a security observability standpoint.</p>
<p>For a Red Teamer, <strong>AF_VSOCK</strong> represents a golden opportunity to:</p>
<ol>
<li>Exfiltrate data stealthily.</li>
<li>Move laterally between operating systems on the same iron.</li>
<li>Evade strict network controls.</li>
</ol>
<p>Tools like <strong>Traveler</strong> are just the tip of the iceberg. As OS integration deepens, security boundaries become blurrier. And it is in that fog where we operate best.</p> </article>  </div> </section>  </main> <footer class="border-t border-terminal-border bg-terminal-black/90"> <div class="mx-auto flex max-w-6xl flex-col gap-2 px-4 py-4 text-xs text-terminal-green/90 md:flex-row md:items-center md:justify-between md:px-8"> <span>Operator: MainDavis</span> <span> Status: active surveillance </span> </div> </footer> </div> </body></html>