<!DOCTYPE html><html lang="en"> <head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1"><meta name="color-scheme" content="dark"><link rel="preconnect" href="https://fonts.googleapis.com"><link rel="preconnect" href="https://fonts.gstatic.com" crossorigin><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=JetBrains+Mono:wght@300;400;500&display=swap"><link rel="icon" href="/favicon.svg"><link rel="canonical" href="https://maindavis.github.io/en/blog/reflectivedllinjection/"><title>Advanced Reflective DLL Injection in Nim: Bypassing the Loader</title><meta name="title" content="Advanced Reflective DLL Injection in Nim: Bypassing the Loader"><meta name="description" content="A deep dive into manual PE mapping using Nim to inject libraries without touching the disk or using standard Windows APIs."><!-- Open Graph / Facebook --><meta property="og:type" content="article"><meta property="og:url" content="https://maindavis.github.io/en/blog/reflectivedllinjection/"><meta property="og:title" content="Advanced Reflective DLL Injection in Nim: Bypassing the Loader"><meta property="og:description" content="A deep dive into manual PE mapping using Nim to inject libraries without touching the disk or using standard Windows APIs."><meta property="og:image" content="https://maindavis.github.io/open-graph/en/reflectivedllinjection.png"><meta property="og:image:width" content="1200"><meta property="og:image:height" content="630"><!-- Twitter --><meta property="twitter:card" content="summary_large_image"><meta property="twitter:url" content="https://maindavis.github.io/en/blog/reflectivedllinjection/"><meta property="twitter:title" content="Advanced Reflective DLL Injection in Nim: Bypassing the Loader"><meta property="twitter:description" content="A deep dive into manual PE mapping using Nim to inject libraries without touching the disk or using standard Windows APIs."><meta property="twitter:image" content="https://maindavis.github.io/open-graph/en/reflectivedllinjection.png"><link rel="stylesheet" href="/_astro/about.B9y4o1ar.css">
<link rel="stylesheet" href="/_astro/index.BcZbEljn.css"></head> <body class="min-h-screen"> <style>astro-island,astro-slot,astro-static-slot{display:contents}</style><script>(()=>{var l=(o,t)=>{let i=async()=>{await(await o())()},e=typeof t.value=="object"?t.value:void 0,s={timeout:e==null?void 0:e.timeout};"requestIdleCallback"in window?window.requestIdleCallback(i,s):setTimeout(i,s.timeout||200)};(self.Astro||(self.Astro={})).idle=l;window.dispatchEvent(new Event("astro:idle"));})();;(()=>{var A=Object.defineProperty;var g=(i,o,a)=>o in i?A(i,o,{enumerable:!0,configurable:!0,writable:!0,value:a}):i[o]=a;var d=(i,o,a)=>g(i,typeof o!="symbol"?o+"":o,a);{let i={0:t=>m(t),1:t=>a(t),2:t=>new RegExp(t),3:t=>new Date(t),4:t=>new Map(a(t)),5:t=>new Set(a(t)),6:t=>BigInt(t),7:t=>new URL(t),8:t=>new Uint8Array(t),9:t=>new Uint16Array(t),10:t=>new Uint32Array(t),11:t=>1/0*t},o=t=>{let[l,e]=t;return l in i?i[l](e):void 0},a=t=>t.map(o),m=t=>typeof t!="object"||t===null?t:Object.fromEntries(Object.entries(t).map(([l,e])=>[l,o(e)]));class y extends HTMLElement{constructor(){super(...arguments);d(this,"Component");d(this,"hydrator");d(this,"hydrate",async()=>{var b;if(!this.hydrator||!this.isConnected)return;let e=(b=this.parentElement)==null?void 0:b.closest("astro-island[ssr]");if(e){e.addEventListener("astro:hydrate",this.hydrate,{once:!0});return}let c=this.querySelectorAll("astro-slot"),n={},h=this.querySelectorAll("template[data-astro-template]");for(let r of h){let s=r.closest(this.tagName);s!=null&&s.isSameNode(this)&&(n[r.getAttribute("data-astro-template")||"default"]=r.innerHTML,r.remove())}for(let r of c){let s=r.closest(this.tagName);s!=null&&s.isSameNode(this)&&(n[r.getAttribute("name")||"default"]=r.innerHTML)}let p;try{p=this.hasAttribute("props")?m(JSON.parse(this.getAttribute("props"))):{}}catch(r){let s=this.getAttribute("component-url")||"<unknown>",v=this.getAttribute("component-export");throw v&&(s+=` (export ${v})`),console.error(`[hydrate] Error parsing props for component ${s}`,this.getAttribute("props"),r),r}let u;await this.hydrator(this)(this.Component,p,n,{client:this.getAttribute("client")}),this.removeAttribute("ssr"),this.dispatchEvent(new CustomEvent("astro:hydrate"))});d(this,"unmount",()=>{this.isConnected||this.dispatchEvent(new CustomEvent("astro:unmount"))})}disconnectedCallback(){document.removeEventListener("astro:after-swap",this.unmount),document.addEventListener("astro:after-swap",this.unmount,{once:!0})}connectedCallback(){if(!this.hasAttribute("await-children")||document.readyState==="interactive"||document.readyState==="complete")this.childrenConnectedCallback();else{let e=()=>{document.removeEventListener("DOMContentLoaded",e),c.disconnect(),this.childrenConnectedCallback()},c=new MutationObserver(()=>{var n;((n=this.lastChild)==null?void 0:n.nodeType)===Node.COMMENT_NODE&&this.lastChild.nodeValue==="astro:end"&&(this.lastChild.remove(),e())});c.observe(this,{childList:!0}),document.addEventListener("DOMContentLoaded",e)}}async childrenConnectedCallback(){let e=this.getAttribute("before-hydration-url");e&&await import(e),this.start()}async start(){let e=JSON.parse(this.getAttribute("opts")),c=this.getAttribute("client");if(Astro[c]===void 0){window.addEventListener(`astro:${c}`,()=>this.start(),{once:!0});return}try{await Astro[c](async()=>{let n=this.getAttribute("renderer-url"),[h,{default:p}]=await Promise.all([import(this.getAttribute("component-url")),n?import(n):()=>()=>{}]),u=this.getAttribute("component-export")||"default";if(!u.includes("."))this.Component=h[u];else{this.Component=h;for(let f of u.split("."))this.Component=this.Component[f]}return this.hydrator=p,this.hydrate},e,this)}catch(n){console.error(`[astro-island] Error hydrating ${this.getAttribute("component-url")}`,n)}}attributeChangedCallback(){this.hydrate()}}d(y,"observedAttributes",["props"]),customElements.get("astro-island")||customElements.define("astro-island",y)}})();</script><astro-island uid="Z2c8VbI" prefix="r0" component-url="/_astro/MatrixRain.TxUs3SNa.js" component-export="default" renderer-url="/_astro/client.BuOr9PT5.js" props="{}" ssr="" client="idle" opts="{&quot;name&quot;:&quot;MatrixRain&quot;,&quot;value&quot;:true}" await-children=""><canvas class="pointer-events-none fixed inset-0 z-0 opacity-40" aria-hidden="true"></canvas><!--astro:end--></astro-island> <astro-island uid="Z1upAD6" prefix="r1" component-url="/_astro/SearchModal.BgunQDqN.js" component-export="default" renderer-url="/_astro/client.BuOr9PT5.js" props="{&quot;locale&quot;:[0,&quot;en&quot;]}" ssr="" client="idle" opts="{&quot;name&quot;:&quot;SearchModal&quot;,&quot;value&quot;:true}"></astro-island> <div class="relative z-10 flex min-h-screen flex-col"> <header class="border-b border-terminal-border bg-terminal-black/90"> <div class="mx-auto flex max-w-6xl flex-col gap-3 px-4 py-4 md:flex-row md:items-center md:justify-between md:px-8"> <div class="flex items-center gap-3 text-xs uppercase tracking-[0.3em] text-terminal-muted/80"> <span class="h-2 w-2 rounded-full bg-terminal-green shadow-glow"></span> SESSION_ACTIVE :: RED_TEAM_ENGAGEMENT </div> <div class="flex flex-wrap items-center gap-3"> <nav class="flex gap-2 text-sm"> <a href="/en" class="rounded-sm border px-3 py-1 transition border-terminal-border text-terminal-muted hover:border-terminal-green hover:shadow-glow-strong"> ~/home </a><a href="/en/blog" class="rounded-sm border px-3 py-1 transition border-terminal-green text-terminal-green text-glow"> ~/blog </a><a href="/en/arsenal" class="rounded-sm border px-3 py-1 transition border-terminal-border text-terminal-muted hover:border-terminal-green hover:shadow-glow-strong"> ~/arsenal </a><a href="/en/about" class="rounded-sm border px-3 py-1 transition border-terminal-border text-terminal-muted hover:border-terminal-green hover:shadow-glow-strong"> ~/about </a> </nav> <a href="/es/blog/reflectivedllinjection" class="rounded-sm border border-terminal-border px-3 py-1 text-xs uppercase tracking-[0.25em] text-terminal-muted transition hover:border-terminal-green hover:text-terminal-green"> ES </a> </div> </div> </header> <main class="flex-1 px-4 pb-12 pt-6 md:px-8">  <section class="mx-auto w-full max-w-5xl"> <div class="panel border-glow rounded-md px-5 py-4"> <h1 class="text-xl text-terminal-green text-glow">Advanced Reflective DLL Injection in Nim: Bypassing the Loader</h1> <p class="mt-2 text-sm text-terminal-cyan/80">A deep dive into manual PE mapping using Nim to inject libraries without touching the disk or using standard Windows APIs.</p> </div> <div class="mt-6">  <div class="post-hero border border-terminal-border/70 rounded-md"> <img src="/images/blog/dll_injection.png" alt="Advanced Reflective DLL Injection in Nim: Bypassing the Loader" loading="eager" decoding="async" fetchpriority="high"> </div> <article class="panel border-glow mt-6 rounded-md px-5 py-5 text-sm leading-relaxed text-terminal-light/90"> <p>Reflective DLL Injection has been a staple in the Red Team arsenal for years. However, the days of simply using Stephen Fewer’s original technique and expecting to bypass modern EDRs are long gone. Today, we are taking a look at how to implement an advanced version of this technique using Nim, focusing on manual mapping to stay as stealthy as possible.</p>
<p>The core idea is simple: instead of letting LoadLibrary do the work (which triggers multiple telemetry points), we act as the Windows PE loader ourselves.</p>
<h1 id="the-manual-mapping-workflow">The Manual Mapping Workflow</h1>
<p>To successfully map a DLL into a remote process, we need to follow the same steps the OS would:</p>
<ol>
<li>
<p>Parsing the PE Header: We need to read the headers to understand where sections go.</p>
</li>
<li>
<p>Allocating Memory: Finding a home for our DLL in the target process.</p>
</li>
<li>
<p>Mapping Sections: Copying .text, .data, and other sections to their relative offsets.</p>
</li>
<li>
<p>Base Relocation: Fixing hardcoded addresses if we didn’t get our preferred base address.</p>
</li>
<li>
<p>Import Resolution: Manually loading the functions our DLL needs to run.</p>
</li>
<li>
<p>Execution: Calling the DllMain entry point.</p>
</li>
</ol>
<h2 id="defining-the-pe-structures-in-nim">Defining the PE Structures in Nim</h2>
<p>Nim’s FFI (Foreign Function Interface) makes it incredibly easy to work with Windows APIs. First, we need to define some structures that Nim doesn’t have by default.</p>
<pre class="astro-code github-dark" style="background-color:#24292e;color:#e1e4e8; overflow-x: auto;" tabindex="0" data-language="nim"><code><span class="line"><span style="color:#F97583">import</span><span style="color:#E1E4E8"> winim</span><span style="color:#F97583">/</span><span style="color:#E1E4E8">lean</span></span>
<span class="line"></span>
<span class="line"><span style="color:#F97583">type</span></span>
<span class="line"><span style="color:#79B8FF">    IMAGE_BASE_RELOCATION</span><span style="color:#E1E4E8"> {.pure.} </span><span style="color:#F97583">=</span><span style="color:#F97583"> object</span></span>
<span class="line"><span style="color:#79B8FF">        VirtualAddress</span><span style="color:#F97583">:</span><span style="color:#79B8FF"> DWORD</span></span>
<span class="line"><span style="color:#79B8FF">        SizeOfBlock</span><span style="color:#F97583">:</span><span style="color:#79B8FF"> DWORD</span></span>
<span class="line"></span>
<span class="line"><span style="color:#79B8FF">    IMAGE_IMPORT_DESCRIPTOR</span><span style="color:#E1E4E8"> {.pure.} </span><span style="color:#F97583">=</span><span style="color:#F97583"> object</span></span>
<span class="line"><span style="color:#79B8FF">        OriginalFirstThunk</span><span style="color:#F97583">:</span><span style="color:#79B8FF"> DWORD</span></span>
<span class="line"><span style="color:#79B8FF">        TimeDateStamp</span><span style="color:#F97583">:</span><span style="color:#79B8FF"> DWORD</span></span>
<span class="line"><span style="color:#79B8FF">        ForwarderChain</span><span style="color:#F97583">:</span><span style="color:#79B8FF"> DWORD</span></span>
<span class="line"><span style="color:#79B8FF">        Name</span><span style="color:#F97583">:</span><span style="color:#79B8FF"> DWORD</span></span>
<span class="line"><span style="color:#79B8FF">        FirstThunk</span><span style="color:#F97583">:</span><span style="color:#79B8FF"> DWORD</span></span>
<span class="line"></span></code></pre>
<h2 id="step-1-memory-allocation-and-section-mapping">Step 1: Memory Allocation and Section Mapping</h2>
<p>We start by allocating memory in the target process. Instead of RWX (Read-Write-Execute) memory, which is a huge red flag, we should initially allocate RW and later change it to RX for the code sections.</p>
<pre class="astro-code github-dark" style="background-color:#24292e;color:#e1e4e8; overflow-x: auto;" tabindex="0" data-language="nim"><code><span class="line"><span style="color:#F97583">proc</span><span style="color:#B392F0"> mapSections</span><span style="color:#E1E4E8">(buffer</span><span style="color:#F97583">:</span><span style="color:#F97583"> pointer</span><span style="color:#E1E4E8">, baseAddress</span><span style="color:#F97583">:</span><span style="color:#F97583"> pointer</span><span style="color:#E1E4E8">)</span><span style="color:#F97583">:</span><span style="color:#F97583"> void</span><span style="color:#F97583"> =</span></span>
<span class="line"><span style="color:#F97583">    let</span><span style="color:#E1E4E8"> ntHeader </span><span style="color:#F97583">=</span><span style="color:#F97583"> cast</span><span style="color:#E1E4E8">[</span><span style="color:#79B8FF">PIMAGE_NT_HEADERS</span><span style="color:#E1E4E8">](</span><span style="color:#F97583">cast</span><span style="color:#E1E4E8">[</span><span style="color:#79B8FF">ByteAddress</span><span style="color:#E1E4E8">](buffer) </span><span style="color:#F97583">+</span><span style="color:#F97583"> cast</span><span style="color:#E1E4E8">[</span><span style="color:#79B8FF">PIMAGE_DOS_HEADER</span><span style="color:#E1E4E8">](buffer)</span><span style="color:#F97583">.</span><span style="color:#E1E4E8">e_lfanew)</span></span>
<span class="line"><span style="color:#F97583">    let</span><span style="color:#E1E4E8"> sectionHeader </span><span style="color:#F97583">=</span><span style="color:#F97583"> cast</span><span style="color:#E1E4E8">[</span><span style="color:#79B8FF">PIMAGE_SECTION_HEADER</span><span style="color:#E1E4E8">](</span><span style="color:#F97583">cast</span><span style="color:#E1E4E8">[</span><span style="color:#79B8FF">ByteAddress</span><span style="color:#E1E4E8">](ntHeader) </span><span style="color:#F97583">+</span><span style="color:#79B8FF"> sizeof</span><span style="color:#E1E4E8">(</span><span style="color:#79B8FF">IMAGE_NT_HEADERS</span><span style="color:#E1E4E8">))</span></span>
<span class="line"></span>
<span class="line"><span style="color:#F97583">    for</span><span style="color:#E1E4E8"> i </span><span style="color:#F97583">in</span><span style="color:#79B8FF"> 0</span><span style="color:#F97583"> ..&#x3C;</span><span style="color:#E1E4E8"> ntHeader</span><span style="color:#F97583">.</span><span style="color:#79B8FF">FileHeader</span><span style="color:#F97583">.</span><span style="color:#79B8FF">NumberOfSections</span><span style="color:#F97583">:</span></span>
<span class="line"><span style="color:#F97583">        let</span><span style="color:#E1E4E8"> section </span><span style="color:#F97583">=</span><span style="color:#F97583"> cast</span><span style="color:#E1E4E8">[</span><span style="color:#79B8FF">PIMAGE_SECTION_HEADER</span><span style="color:#E1E4E8">](</span><span style="color:#F97583">cast</span><span style="color:#E1E4E8">[</span><span style="color:#79B8FF">ByteAddress</span><span style="color:#E1E4E8">](sectionHeader) </span><span style="color:#F97583">+</span><span style="color:#E1E4E8"> (</span><span style="color:#79B8FF">i </span><span style="color:#F97583">*</span><span style="color:#79B8FF"> sizeof</span><span style="color:#E1E4E8">(</span><span style="color:#79B8FF">IMAGE_SECTION_HEADER</span><span style="color:#E1E4E8">)))</span></span>
<span class="line"><span style="color:#F97583">        let</span><span style="color:#E1E4E8"> dest </span><span style="color:#F97583">=</span><span style="color:#F97583"> cast</span><span style="color:#E1E4E8">[</span><span style="color:#F97583">pointer</span><span style="color:#E1E4E8">](</span><span style="color:#F97583">cast</span><span style="color:#E1E4E8">[</span><span style="color:#79B8FF">ByteAddress</span><span style="color:#E1E4E8">](baseAddress) </span><span style="color:#F97583">+</span><span style="color:#E1E4E8"> section</span><span style="color:#F97583">.</span><span style="color:#79B8FF">VirtualAddress</span><span style="color:#E1E4E8">)</span></span>
<span class="line"><span style="color:#F97583">        let</span><span style="color:#E1E4E8"> src </span><span style="color:#F97583">=</span><span style="color:#F97583"> cast</span><span style="color:#E1E4E8">[</span><span style="color:#F97583">pointer</span><span style="color:#E1E4E8">](</span><span style="color:#F97583">cast</span><span style="color:#E1E4E8">[</span><span style="color:#79B8FF">ByteAddress</span><span style="color:#E1E4E8">](buffer) </span><span style="color:#F97583">+</span><span style="color:#E1E4E8"> section</span><span style="color:#F97583">.</span><span style="color:#79B8FF">PointerToRawData</span><span style="color:#E1E4E8">)</span></span>
<span class="line"><span style="color:#E1E4E8">        </span></span>
<span class="line"><span style="color:#79B8FF">        copyMem</span><span style="color:#E1E4E8">(dest, src, section</span><span style="color:#F97583">.</span><span style="color:#79B8FF">SizeOfRawData</span><span style="color:#E1E4E8">)</span></span>
<span class="line"></span></code></pre>
<h2 id="step-2-the-relocation-process">Step 2: The Relocation Process</h2>
<p>Since we rarely get the base address the DLL prefers, we must calculate the “delta” (the difference between the preferred and the actual address) and apply it to every absolute address in the code.</p>
<pre class="astro-code github-dark" style="background-color:#24292e;color:#e1e4e8; overflow-x: auto;" tabindex="0" data-language="nim"><code><span class="line"><span style="color:#F97583">proc</span><span style="color:#B392F0"> applyRelocations</span><span style="color:#E1E4E8">(buffer</span><span style="color:#F97583">:</span><span style="color:#F97583"> pointer</span><span style="color:#E1E4E8">, baseAddress</span><span style="color:#F97583">:</span><span style="color:#F97583"> pointer</span><span style="color:#E1E4E8">, delta</span><span style="color:#F97583">:</span><span style="color:#F97583"> int64</span><span style="color:#E1E4E8">)</span><span style="color:#F97583">:</span><span style="color:#F97583"> void</span><span style="color:#F97583"> =</span></span>
<span class="line"><span style="color:#6A737D">    # Logic to iterate through IMAGE_DIRECTORY_ENTRY_BASERELOC</span></span>
<span class="line"><span style="color:#6A737D">    # and patch the addresses in memory</span></span>
<span class="line"><span style="color:#F97583">    discard</span></span>
<span class="line"></span></code></pre>
<h2 id="step-3-resolving-imports">Step 3: Resolving Imports</h2>
<p>This is where many detections happen. Instead of calling GetProcAddress repeatedly, we can parse the export table of ntdll.dll or kernel32.dll manually to find the functions we need.</p>
<pre class="astro-code github-dark" style="background-color:#24292e;color:#e1e4e8; overflow-x: auto;" tabindex="0" data-language="nim"><code><span class="line"><span style="color:#F97583">proc</span><span style="color:#B392F0"> resolveImports</span><span style="color:#E1E4E8">(baseAddress</span><span style="color:#F97583">:</span><span style="color:#F97583"> pointer</span><span style="color:#E1E4E8">)</span><span style="color:#F97583">:</span><span style="color:#F97583"> void</span><span style="color:#F97583"> =</span></span>
<span class="line"><span style="color:#F97583">    let</span><span style="color:#E1E4E8"> ntHeader </span><span style="color:#F97583">=</span><span style="color:#F97583"> cast</span><span style="color:#E1E4E8">[</span><span style="color:#79B8FF">PIMAGE_NT_HEADERS</span><span style="color:#E1E4E8">](</span><span style="color:#F97583">cast</span><span style="color:#E1E4E8">[</span><span style="color:#79B8FF">ByteAddress</span><span style="color:#E1E4E8">](baseAddress) </span><span style="color:#F97583">+</span><span style="color:#F97583"> cast</span><span style="color:#E1E4E8">[</span><span style="color:#79B8FF">PIMAGE_DOS_HEADER</span><span style="color:#E1E4E8">](baseAddress)</span><span style="color:#F97583">.</span><span style="color:#E1E4E8">e_lfanew)</span></span>
<span class="line"><span style="color:#F97583">    let</span><span style="color:#E1E4E8"> importDir </span><span style="color:#F97583">=</span><span style="color:#E1E4E8"> ntHeader</span><span style="color:#F97583">.</span><span style="color:#79B8FF">OptionalHeader</span><span style="color:#F97583">.</span><span style="color:#79B8FF">DataDirectory</span><span style="color:#E1E4E8">[</span><span style="color:#79B8FF">IMAGE_DIRECTORY_ENTRY_IMPORT</span><span style="color:#E1E4E8">]</span></span>
<span class="line"><span style="color:#E1E4E8">    </span></span>
<span class="line"><span style="color:#6A737D">    # Iterate through IMAGE_IMPORT_DESCRIPTORs</span></span>
<span class="line"><span style="color:#6A737D">    # Load required DLLs and fix the IAT (Import Address Table)</span></span>
<span class="line"></span></code></pre>
<h2 id="why-nim-for-this">Why Nim for this?</h2>
<p>Nim offers a unique balance. You get the low-level control of C with a much more modern syntax. Plus, the winim library provides excellent bindings. When compiled, Nim generates C code, which means we can apply advanced obfuscation at the source level before it ever hits a compiler like MinGW or MSVC.</p>
<h2 id="final-execution">Final Execution</h2>
<p>Once the DLL is mapped and fixed, we point a thread to the DllMain.</p>
<pre class="astro-code github-dark" style="background-color:#24292e;color:#e1e4e8; overflow-x: auto;" tabindex="0" data-language="nim"><code><span class="line"><span style="color:#F97583">let</span><span style="color:#E1E4E8"> dllMain </span><span style="color:#F97583">=</span><span style="color:#F97583"> cast</span><span style="color:#E1E4E8">[</span><span style="color:#F97583">proc</span><span style="color:#E1E4E8">(hinst</span><span style="color:#F97583">:</span><span style="color:#79B8FF"> HINSTANCE</span><span style="color:#E1E4E8">, reason</span><span style="color:#F97583">:</span><span style="color:#79B8FF"> DWORD</span><span style="color:#E1E4E8">, reserved</span><span style="color:#F97583">:</span><span style="color:#79B8FF"> LPVOID</span><span style="color:#E1E4E8">)</span><span style="color:#F97583">:</span><span style="color:#79B8FF"> BOOL</span><span style="color:#E1E4E8"> {.stdcall.}](</span></span>
<span class="line"><span style="color:#F97583">    cast</span><span style="color:#E1E4E8">[</span><span style="color:#79B8FF">ByteAddress</span><span style="color:#E1E4E8">](baseAddress) </span><span style="color:#F97583">+</span><span style="color:#E1E4E8"> ntHeader</span><span style="color:#F97583">.</span><span style="color:#79B8FF">OptionalHeader</span><span style="color:#F97583">.</span><span style="color:#79B8FF">AddressOfEntryPoint</span></span>
<span class="line"><span style="color:#E1E4E8">)</span></span>
<span class="line"></span>
<span class="line"><span style="color:#79B8FF">dllMain</span><span style="color:#E1E4E8">(</span><span style="color:#F97583">cast</span><span style="color:#E1E4E8">[</span><span style="color:#79B8FF">HINSTANCE</span><span style="color:#E1E4E8">](baseAddress), </span><span style="color:#79B8FF">DLL_PROCESS_ATTACH</span><span style="color:#E1E4E8">, </span><span style="color:#79B8FF">nil</span><span style="color:#E1E4E8">)</span></span>
<span class="line"></span></code></pre>
<h1 id="stealth-considerations">Stealth Considerations</h1>
<p>To take this to a professional level, consider:</p>
<ul>
<li>
<p>Module Overloading: Mapping your DLL over a legitimate, already loaded Windows DLL.</p>
</li>
<li>
<p>Stack Spoofing: Hiding the return address of your thread to point back to legitimate code.</p>
</li>
<li>
<p>Custom Syscalls: Using Nim to perform NtAllocateVirtualMemory via direct syscalls to avoid EDR hooks.</p>
</li>
</ul>
<p>This approach is significantly more robust than basic injection. It leaves no files on disk and avoids the most common API hooks used by defensive tools.</p> </article>  </div> </section>  </main> <footer class="border-t border-terminal-border bg-terminal-black/90"> <div class="mx-auto flex max-w-6xl flex-col gap-2 px-4 py-4 text-xs text-terminal-green/90 md:flex-row md:items-center md:justify-between md:px-8"> <span>Operator: MainDavis</span> <span> Status: active surveillance </span> </div> </footer> </div> </body></html>