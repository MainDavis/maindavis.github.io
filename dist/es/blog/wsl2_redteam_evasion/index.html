<!DOCTYPE html><html lang="es"> <head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1"><meta name="color-scheme" content="dark"><link rel="preconnect" href="https://fonts.googleapis.com"><link rel="preconnect" href="https://fonts.gstatic.com" crossorigin><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=JetBrains+Mono:wght@300;400;500&display=swap"><link rel="icon" href="/favicon.svg"><link rel="canonical" href="https://maindavis.github.io/es/blog/wsl2_redteam_evasion/"><title>Red Team con WSL2: Punto Ciego en la Monitorización de Red</title><meta name="title" content="Red Team con WSL2: Punto Ciego en la Monitorización de Red"><meta name="description" content="Cómo un Red Teamer puede abusar de los canales de comunicación de Hyper-V (AF_VSOCK) para comunicaciones ocultas y movimiento lateral Cross-OS."><!-- Open Graph / Facebook --><meta property="og:type" content="article"><meta property="og:url" content="https://maindavis.github.io/es/blog/wsl2_redteam_evasion/"><meta property="og:title" content="Red Team con WSL2: Punto Ciego en la Monitorización de Red"><meta property="og:description" content="Cómo un Red Teamer puede abusar de los canales de comunicación de Hyper-V (AF_VSOCK) para comunicaciones ocultas y movimiento lateral Cross-OS."><meta property="og:image" content="https://maindavis.github.io/open-graph/es/wsl2_redteam_evasion.png"><meta property="og:image:width" content="1200"><meta property="og:image:height" content="630"><!-- Twitter --><meta property="twitter:card" content="summary_large_image"><meta property="twitter:url" content="https://maindavis.github.io/es/blog/wsl2_redteam_evasion/"><meta property="twitter:title" content="Red Team con WSL2: Punto Ciego en la Monitorización de Red"><meta property="twitter:description" content="Cómo un Red Teamer puede abusar de los canales de comunicación de Hyper-V (AF_VSOCK) para comunicaciones ocultas y movimiento lateral Cross-OS."><meta property="twitter:image" content="https://maindavis.github.io/open-graph/es/wsl2_redteam_evasion.png"><link rel="stylesheet" href="/_astro/about.B9y4o1ar.css">
<link rel="stylesheet" href="/_astro/index.BcZbEljn.css"></head> <body class="min-h-screen"> <style>astro-island,astro-slot,astro-static-slot{display:contents}</style><script>(()=>{var l=(o,t)=>{let i=async()=>{await(await o())()},e=typeof t.value=="object"?t.value:void 0,s={timeout:e==null?void 0:e.timeout};"requestIdleCallback"in window?window.requestIdleCallback(i,s):setTimeout(i,s.timeout||200)};(self.Astro||(self.Astro={})).idle=l;window.dispatchEvent(new Event("astro:idle"));})();;(()=>{var A=Object.defineProperty;var g=(i,o,a)=>o in i?A(i,o,{enumerable:!0,configurable:!0,writable:!0,value:a}):i[o]=a;var d=(i,o,a)=>g(i,typeof o!="symbol"?o+"":o,a);{let i={0:t=>m(t),1:t=>a(t),2:t=>new RegExp(t),3:t=>new Date(t),4:t=>new Map(a(t)),5:t=>new Set(a(t)),6:t=>BigInt(t),7:t=>new URL(t),8:t=>new Uint8Array(t),9:t=>new Uint16Array(t),10:t=>new Uint32Array(t),11:t=>1/0*t},o=t=>{let[l,e]=t;return l in i?i[l](e):void 0},a=t=>t.map(o),m=t=>typeof t!="object"||t===null?t:Object.fromEntries(Object.entries(t).map(([l,e])=>[l,o(e)]));class y extends HTMLElement{constructor(){super(...arguments);d(this,"Component");d(this,"hydrator");d(this,"hydrate",async()=>{var b;if(!this.hydrator||!this.isConnected)return;let e=(b=this.parentElement)==null?void 0:b.closest("astro-island[ssr]");if(e){e.addEventListener("astro:hydrate",this.hydrate,{once:!0});return}let c=this.querySelectorAll("astro-slot"),n={},h=this.querySelectorAll("template[data-astro-template]");for(let r of h){let s=r.closest(this.tagName);s!=null&&s.isSameNode(this)&&(n[r.getAttribute("data-astro-template")||"default"]=r.innerHTML,r.remove())}for(let r of c){let s=r.closest(this.tagName);s!=null&&s.isSameNode(this)&&(n[r.getAttribute("name")||"default"]=r.innerHTML)}let p;try{p=this.hasAttribute("props")?m(JSON.parse(this.getAttribute("props"))):{}}catch(r){let s=this.getAttribute("component-url")||"<unknown>",v=this.getAttribute("component-export");throw v&&(s+=` (export ${v})`),console.error(`[hydrate] Error parsing props for component ${s}`,this.getAttribute("props"),r),r}let u;await this.hydrator(this)(this.Component,p,n,{client:this.getAttribute("client")}),this.removeAttribute("ssr"),this.dispatchEvent(new CustomEvent("astro:hydrate"))});d(this,"unmount",()=>{this.isConnected||this.dispatchEvent(new CustomEvent("astro:unmount"))})}disconnectedCallback(){document.removeEventListener("astro:after-swap",this.unmount),document.addEventListener("astro:after-swap",this.unmount,{once:!0})}connectedCallback(){if(!this.hasAttribute("await-children")||document.readyState==="interactive"||document.readyState==="complete")this.childrenConnectedCallback();else{let e=()=>{document.removeEventListener("DOMContentLoaded",e),c.disconnect(),this.childrenConnectedCallback()},c=new MutationObserver(()=>{var n;((n=this.lastChild)==null?void 0:n.nodeType)===Node.COMMENT_NODE&&this.lastChild.nodeValue==="astro:end"&&(this.lastChild.remove(),e())});c.observe(this,{childList:!0}),document.addEventListener("DOMContentLoaded",e)}}async childrenConnectedCallback(){let e=this.getAttribute("before-hydration-url");e&&await import(e),this.start()}async start(){let e=JSON.parse(this.getAttribute("opts")),c=this.getAttribute("client");if(Astro[c]===void 0){window.addEventListener(`astro:${c}`,()=>this.start(),{once:!0});return}try{await Astro[c](async()=>{let n=this.getAttribute("renderer-url"),[h,{default:p}]=await Promise.all([import(this.getAttribute("component-url")),n?import(n):()=>()=>{}]),u=this.getAttribute("component-export")||"default";if(!u.includes("."))this.Component=h[u];else{this.Component=h;for(let f of u.split("."))this.Component=this.Component[f]}return this.hydrator=p,this.hydrate},e,this)}catch(n){console.error(`[astro-island] Error hydrating ${this.getAttribute("component-url")}`,n)}}attributeChangedCallback(){this.hydrate()}}d(y,"observedAttributes",["props"]),customElements.get("astro-island")||customElements.define("astro-island",y)}})();</script><astro-island uid="Z2c8VbI" prefix="r0" component-url="/_astro/MatrixRain.TxUs3SNa.js" component-export="default" renderer-url="/_astro/client.BuOr9PT5.js" props="{}" ssr="" client="idle" opts="{&quot;name&quot;:&quot;MatrixRain&quot;,&quot;value&quot;:true}" await-children=""><canvas class="pointer-events-none fixed inset-0 z-0 opacity-40" aria-hidden="true"></canvas><!--astro:end--></astro-island> <astro-island uid="Z1uoVBd" prefix="r1" component-url="/_astro/SearchModal.BgunQDqN.js" component-export="default" renderer-url="/_astro/client.BuOr9PT5.js" props="{&quot;locale&quot;:[0,&quot;es&quot;]}" ssr="" client="idle" opts="{&quot;name&quot;:&quot;SearchModal&quot;,&quot;value&quot;:true}"></astro-island> <div class="relative z-10 flex min-h-screen flex-col"> <header class="border-b border-terminal-border bg-terminal-black/90"> <div class="mx-auto flex max-w-6xl flex-col gap-3 px-4 py-4 md:flex-row md:items-center md:justify-between md:px-8"> <div class="flex items-center gap-3 text-xs uppercase tracking-[0.3em] text-terminal-muted/80"> <span class="h-2 w-2 rounded-full bg-terminal-green shadow-glow"></span> SESION_ACTIVA :: OPERACION_RED_TEAM </div> <div class="flex flex-wrap items-center gap-3"> <nav class="flex gap-2 text-sm"> <a href="/es" class="rounded-sm border px-3 py-1 transition border-terminal-border text-terminal-muted hover:border-terminal-green hover:shadow-glow-strong"> ~/inicio </a><a href="/es/blog" class="rounded-sm border px-3 py-1 transition border-terminal-green text-terminal-green text-glow"> ~/blog </a><a href="/es/arsenal" class="rounded-sm border px-3 py-1 transition border-terminal-border text-terminal-muted hover:border-terminal-green hover:shadow-glow-strong"> ~/arsenal </a><a href="/es/about" class="rounded-sm border px-3 py-1 transition border-terminal-border text-terminal-muted hover:border-terminal-green hover:shadow-glow-strong"> ~/perfil </a> </nav> <a href="/en/blog/wsl2_redteam_evasion" class="rounded-sm border border-terminal-border px-3 py-1 text-xs uppercase tracking-[0.25em] text-terminal-muted transition hover:border-terminal-green hover:text-terminal-green"> EN </a> </div> </div> </header> <main class="flex-1 px-4 pb-12 pt-6 md:px-8">  <section class="mx-auto w-full max-w-5xl"> <div class="panel border-glow rounded-md px-5 py-4"> <h1 class="text-xl text-terminal-green text-glow">Red Team con WSL2: Punto Ciego en la Monitorización de Red</h1> <p class="mt-2 text-sm text-terminal-cyan/80">Cómo un Red Teamer puede abusar de los canales de comunicación de Hyper-V (AF_VSOCK) para comunicaciones ocultas y movimiento lateral Cross-OS.</p> </div> <div class="mt-6">  <div class="post-hero border border-terminal-border/70 rounded-md"> <img src="/images/blog/wsl2_evasion.png" alt="Red Team con WSL2: Punto Ciego en la Monitorización de Red" loading="eager" decoding="async" fetchpriority="high"> </div> <article class="panel border-glow mt-6 rounded-md px-5 py-5 text-sm leading-relaxed text-terminal-light/90"> <p>El desafío de operar sigilosamente en entornos Windows ha llegado a un punto de saturación en el “User Land”. Hooks en <code>ntdll</code>, monitoreo de ETW (Event Tracing for Windows), y filtros NDIS en la pila de red hacen que moverse o ejecutar código sea cada vez más ruidoso.</p>
<p>Pero, ¿y si te dijera que hay un túnel directo al kernel de Windows que la mayoría de las soluciones de seguridad ignoran por completo? Bienvenido a <strong>WSL2</strong> y el mundo de los <strong>Hyper-V Sockets (AF_VSOCK)</strong>.</p>
<h2 id="el-cambio-de-paradigma-desacople-y-shadow-instances">El Cambio de Paradigma: Desacople y “Shadow Instances”</h2>
<p>Tradicionalmente, tratamos a WSL (Windows Subsystem for Linux) como una simple herramienta. Pero para un Red Teamer, es una <strong>“Instancia en la Sombra” (Shadow Instance)</strong>: un sistema operativo completo que comparte el hardware pero no la supervisión de seguridad del Host.</p>
<p>Es vital aclarar un mito común: <strong>WSL2 no te hace invisible al firewall perimetral corporativo</strong>. El tráfico que sale de Linux hacia internet (ej. tu C2) sigue pasando por la interfaz <code>vEthernet</code> y finalmente por la NIC física, siendo visible para un Palo Alto o BlueCoat.</p>
<p>La verdadera ventaja es el <strong>Desacople de Correlación</strong>. Aunque el tráfico sale por la NIC física y es visible para el firewall, el proceso origen es un binario de Linux (ej. <code>curl</code> o un ELF custom), <strong>no un proceso de Windows</strong>.
Esto rompe la cadena de correlación típica de las herramientas de monitorización que buscan “Proceso Windows X haciendo conexión Y”. El firewall ve el tráfico, pero el sistema no ve qué proceso de Windows lo generó (porque no lo generó Windows).</p>
<h2 id="profundizando-en-el-abismo-arquitectura-de-bajo-nivel">Profundizando en el Abismo: Arquitectura de Bajo Nivel</h2>
<p>Para entender la verdadera invisibilidad de esta técnica, debemos diseccionar la arquitectura de WSL2 más allá de lo superficial.</p>
<h3 id="1-la-jerarquía-de-privilegios-rings">1. La Jerarquía de Privilegios (Rings)</h3>
<p>En una máquina con Windows moderno y VBS (Virtualization-based Security) activado:</p>
<ul>
<li><strong>Ring 3 (User Mode)</strong>: Donde viven tus aplicaciones y los agentes de seguridad.</li>
<li><strong>Ring 0 (Kernel Mode)</strong>: El reino de los drivers, el kernel de NT y los callbacks de seguridad que alimentan la telemetría.</li>
<li><strong>Ring -1 (Hypervisor)</strong>: Aquí reina Hyper-V. Es el nivel más privilegiado.</li>
</ul>
<p>WSL2 no es un proceso contenedorizado; es una <strong>Lightweight Utility VM</strong>. Linux corre en su propio kernel en paralelo al kernel de Windows. Cuando usamos <code>AF_VSOCK</code>, la comunicación es facilitada por el Hypervisor mediante <strong>canales de memoria compartida</strong> y mecanismos de señalización, en lugar de una red virtualizada tradicional.</p>
<h3 id="2-vmbus-la-autopista-de-memoria">2. VMBus: La Autopista de Memoria</h3>
<p>El <strong>VMBus</strong> es un mecanismo de transporte lógico entre particiones de Hyper-V. No es una red; es un canal de memoria compartida basado en Ring Buffers.</p>
<ul>
<li><strong>En Linux (Guest)</strong>: El driver <code>hv_sock</code> (<code>drivers/hv/hv_sock.c</code>) expone la familia de direcciones <code>AF_VSOCK</code>. Al escribir en el socket, los datos se copian directamente al Ring Buffer del VMBus.</li>
<li><strong>En Windows (Host)</strong>: El driver <code>hvsock.sys</code> (Kernel Mode) recoge estos datos desde el VMBus y los entrega al servicio o proceso que escucha en <code>AF_HYPERV</code>.</li>
</ul>
<h3 id="3-el-punto-ciego-ndis-y-wfp">3. El Punto Ciego: NDIS y WFP</h3>
<p>La mayoría de las soluciones de monitorización de red en Windows (Firewalls personales, sensores con inspección de red) se anclan en dos puntos:</p>
<ol>
<li><strong>NDIS (Network Driver Interface Specification)</strong>: Filtros para drivers de red física o virtual (<code>vEthernet</code>).</li>
<li><strong>WFP (Windows Filtering Platform)</strong>: Callouts para inspeccionar paquetes TCP/IP, UDP, etc.</li>
</ol>
<p><strong>El tráfico de AF_VSOCK nunca es encapsulado en un paquete IP</strong>. No tiene cabeceras Ethernet, ni IP, ni TCP. Es un stream de bytes crudo (Byte Stream) que fluye de memoria a memoria gestionado por el Hypervisor.
Como resultado, el tráfico <strong>pasa por debajo</strong> de los filtros NDIS y WFP. Para una solución que vigila la pila de red, esta comunicación simplemente <em>no existe</em>.</p>
<p>El esquema de direccionamiento es simple y ajeno a IP:</p>
<ul>
<li><strong>CID (Context Identifier)</strong>: <code>CID_HOST (2)</code> es nuestra puerta trasera al Windows Host.</li>
<li><strong>Puerto</strong>: Un entero de 32 bits.</li>
</ul>
<h2 id="weaponizando-la-virtualización">Weaponizando la Virtualización</h2>
<p>Aquí es donde entra el ataque <strong>Cross-OS</strong>. Esta técnica brilla en escenarios de <strong>Post-Explotación</strong>: ya has comprometido la “Shadow Instance” (Linux) o el Host, y buscas persistencia o movimiento lateral sigiloso.
Si controlamos Linux, podemos bombear datos arbitrarios hacia Windows. Solo necesitamos que un usuario ejecute (o inyectar) un pequeño “Receiver” en Windows que escuche en el socket.</p>
<h3 id="traveler-la-prueba-de-concepto">Traveler: La Prueba de Concepto</h3>
<p>Para demostrar esto, desarrollé <strong>Traveler</strong> (puedes ver el código fuente en el repositorio), una herramienta diseñada para inyectar shellcode desde WSL2 directamente a la memoria de Windows.</p>
<p>La arquitectura del ataque es la siguiente:</p>
<ol>
<li><strong>Leymano (Sender - Linux)</strong>: Cifra el payload (shellcode) y lo envía a través de un socket <code>AF_VSOCK</code> hacia el CID 2.</li>
<li><strong>Anchor (Receiver - Windows)</strong>: Escucha en <code>AF_HYPERV</code> (la implementación de Windows de vsock), recibe el stream, lo descifra en memoria y lo ejecuta.</li>
</ol>
<p>Lo brillante de este esquema no es la ejecución en sí, sino el <strong>transporte</strong>. El payload nunca toca el disco en Windows (evitando escaneos de AV estáticos) y nunca viaja por la red (evitando IDS/IPS corporativos).</p>
<h2 id="show-me-the-code-nim">Show me the Code (Nim)</h2>
<p>Implementar esto es sorprendentemente sencillo gracias a lenguajes modernos como Nim, que nos permite interactuar con la API de Windows y los syscalls de Linux con facilidad.</p>
<h3 id="el-lado-del-host-windows">El Lado del Host (Windows)</h3>
<p>En Windows, necesitamos definir la estructura <code>SOCKADDR_HV</code> manualmente, ya que no es estándar en todos los headers. Observa el <code>VmId</code> y <code>ServiceId</code>.</p>
<pre class="astro-code github-dark" style="background-color:#24292e;color:#e1e4e8; overflow-x: auto;" tabindex="0" data-language="nim"><code><span class="line"><span style="color:#F97583">import</span><span style="color:#E1E4E8"> winim</span><span style="color:#F97583">/</span><span style="color:#E1E4E8">lean</span></span>
<span class="line"></span>
<span class="line"><span style="color:#6A737D"># Definición de la estructura para Hyper-V Sockets</span></span>
<span class="line"><span style="color:#F97583">type</span><span style="color:#79B8FF"> SOCKADDR_HV</span><span style="color:#E1E4E8"> {.pure, final.} </span><span style="color:#F97583">=</span><span style="color:#F97583"> object</span></span>
<span class="line"><span style="color:#79B8FF">  Family</span><span style="color:#F97583">*:</span><span style="color:#79B8FF"> USHORT</span></span>
<span class="line"><span style="color:#79B8FF">  Reserved</span><span style="color:#F97583">*:</span><span style="color:#79B8FF"> USHORT</span></span>
<span class="line"><span style="color:#79B8FF">  VmId</span><span style="color:#F97583">*:</span><span style="color:#79B8FF"> GUID</span><span style="color:#6A737D">      # ID de la VM (o del Host)</span></span>
<span class="line"><span style="color:#79B8FF">  ServiceId</span><span style="color:#F97583">*:</span><span style="color:#79B8FF"> GUID</span><span style="color:#6A737D"> # ID del servicio (similar al puerto)</span></span>
<span class="line"></span>
<span class="line"><span style="color:#6A737D"># Template para el GUID de VSOCK</span></span>
<span class="line"><span style="color:#6A737D"># Fíjate cómo el puerto se incrusta en el primer dword del GUID</span></span>
<span class="line"><span style="color:#F97583">proc</span><span style="color:#B392F0"> makeServiceGUID</span><span style="color:#E1E4E8">(port</span><span style="color:#F97583">:</span><span style="color:#F97583"> uint32</span><span style="color:#E1E4E8">)</span><span style="color:#F97583">:</span><span style="color:#79B8FF"> GUID</span><span style="color:#F97583"> =</span></span>
<span class="line"><span style="color:#E1E4E8">  result </span><span style="color:#F97583">=</span><span style="color:#79B8FF"> GUID</span><span style="color:#E1E4E8">(</span><span style="color:#79B8FF">Data1</span><span style="color:#F97583">:</span><span style="color:#E1E4E8"> port</span><span style="color:#F97583">.int32</span><span style="color:#E1E4E8">, </span><span style="color:#79B8FF">Data2</span><span style="color:#F97583">:</span><span style="color:#79B8FF"> 0xfacb</span><span style="color:#E1E4E8">, </span><span style="color:#79B8FF">Data3</span><span style="color:#F97583">:</span><span style="color:#79B8FF"> 0x11e6</span><span style="color:#E1E4E8">, </span></span>
<span class="line"><span style="color:#79B8FF">                Data4</span><span style="color:#F97583">:</span><span style="color:#E1E4E8"> [</span><span style="color:#79B8FF">0xbd</span><span style="color:#F97583">.byte</span><span style="color:#E1E4E8">, </span><span style="color:#79B8FF">0x58</span><span style="color:#E1E4E8">, </span><span style="color:#79B8FF">0x64</span><span style="color:#E1E4E8">, </span><span style="color:#79B8FF">0x00</span><span style="color:#E1E4E8">, </span><span style="color:#79B8FF">0x6a</span><span style="color:#E1E4E8">, </span><span style="color:#79B8FF">0x79</span><span style="color:#E1E4E8">, </span><span style="color:#79B8FF">0x86</span><span style="color:#E1E4E8">, </span><span style="color:#79B8FF">0xd3</span><span style="color:#E1E4E8">])</span></span>
<span class="line"></span></code></pre>
<p>Para escuchar, simplemente creamos un socket con la familia <code>AF_HYPERV</code> (34):</p>
<pre class="astro-code github-dark" style="background-color:#24292e;color:#e1e4e8; overflow-x: auto;" tabindex="0" data-language="nim"><code><span class="line"><span style="color:#F97583">var</span><span style="color:#E1E4E8"> s </span><span style="color:#F97583">=</span><span style="color:#79B8FF"> socket</span><span style="color:#E1E4E8">(</span><span style="color:#79B8FF">34</span><span style="color:#E1E4E8">, </span><span style="color:#79B8FF">SOCK_STREAM</span><span style="color:#E1E4E8">, </span><span style="color:#79B8FF">1</span><span style="color:#E1E4E8">) </span><span style="color:#6A737D"># AF_HYPERV, 1 = HV_PROTOCOL_RAW</span></span>
<span class="line"><span style="color:#F97583">bind</span><span style="color:#E1E4E8">(s, </span><span style="color:#F97583">...</span><span style="color:#E1E4E8">)</span></span>
<span class="line"><span style="color:#79B8FF">listen</span><span style="color:#E1E4E8">(s, </span><span style="color:#79B8FF">1</span><span style="color:#E1E4E8">)</span></span>
<span class="line"></span></code></pre>
<h3 id="el-lado-del-guest-linux">El Lado del Guest (Linux)</h3>
<p>Desde Linux, conectar es trivial. Usamos la familia estándar <code>AF_VSOCK</code> (40) y apuntamos al <code>CID_HOST</code> (2).</p>
<pre class="astro-code github-dark" style="background-color:#24292e;color:#e1e4e8; overflow-x: auto;" tabindex="0" data-language="nim"><code><span class="line"><span style="color:#F97583">import</span><span style="color:#E1E4E8"> posix</span></span>
<span class="line"></span>
<span class="line"><span style="color:#F97583">const</span></span>
<span class="line"><span style="color:#79B8FF">  AF_VSOCK</span><span style="color:#F97583"> =</span><span style="color:#79B8FF"> 40</span></span>
<span class="line"><span style="color:#79B8FF">  VMADDR_CID_HOST</span><span style="color:#F97583"> =</span><span style="color:#79B8FF"> 2</span></span>
<span class="line"><span style="color:#79B8FF">  TARGET_PORT</span><span style="color:#F97583"> =</span><span style="color:#79B8FF"> 5005</span></span>
<span class="line"></span>
<span class="line"><span style="color:#F97583">var</span><span style="color:#E1E4E8"> fd </span><span style="color:#F97583">=</span><span style="color:#79B8FF"> socket</span><span style="color:#E1E4E8">(</span><span style="color:#79B8FF">AF_VSOCK</span><span style="color:#E1E4E8">, </span><span style="color:#79B8FF">SOCK_STREAM</span><span style="color:#E1E4E8">, </span><span style="color:#79B8FF">0</span><span style="color:#E1E4E8">)</span></span>
<span class="line"></span>
<span class="line"><span style="color:#F97583">var</span><span style="color:#E1E4E8"> addr_vm</span><span style="color:#F97583">:</span><span style="color:#79B8FF"> SockAddr_VM</span></span>
<span class="line"><span style="color:#E1E4E8">addr_vm</span><span style="color:#F97583">.</span><span style="color:#E1E4E8">svm_family </span><span style="color:#F97583">=</span><span style="color:#79B8FF"> AF_VSOCK</span></span>
<span class="line"><span style="color:#E1E4E8">addr_vm</span><span style="color:#F97583">.</span><span style="color:#E1E4E8">svm_port </span><span style="color:#F97583">=</span><span style="color:#79B8FF"> TARGET_PORT</span></span>
<span class="line"><span style="color:#E1E4E8">addr_vm</span><span style="color:#F97583">.</span><span style="color:#E1E4E8">svm_cid </span><span style="color:#F97583">=</span><span style="color:#79B8FF"> VMADDR_CID_HOST</span></span>
<span class="line"></span>
<span class="line"><span style="color:#6A737D"># Conectando directamente al kernel de Windows...</span></span>
<span class="line"><span style="color:#79B8FF">connect</span><span style="color:#E1E4E8">(fd, addr_vm, </span><span style="color:#F97583">...</span><span style="color:#E1E4E8">)</span></span>
<span class="line"><span style="color:#79B8FF">send</span><span style="color:#E1E4E8">(fd, payload, </span><span style="color:#F97583">...</span><span style="color:#E1E4E8">)</span></span>
<span class="line"></span></code></pre>
<h2 id="conclusión-la-superficie-de-ataque-oculta">Conclusión: La Superficie de Ataque Oculta</h2>
<p>WSL2 ha traído Linux al escritorio de Windows, pero también ha traído nuevas primitivas de comunicación que aún no están totalmente maduras desde el punto de vista de la observabilidad de seguridad.</p>
<p>Para un Red Teamer, <strong>AF_VSOCK</strong> representa una oportunidad de oro para:</p>
<ol>
<li>Exfiltrar datos de forma sigilosa.</li>
<li>Moverse lateralmente entre sistemas operativos en el mismo hierro.</li>
<li>Evadir controles de red estrictos.</li>
</ol>
<p>Las herramientas como <strong>Traveler</strong> son solo la punta del iceberg. A medida que la integración entre sistemas operativos se profundiza, las fronteras de seguridad se vuelven más difusas. Y es en esa niebla donde nosotros operamos mejor.</p> </article>  </div> </section>  </main> <footer class="border-t border-terminal-border bg-terminal-black/90"> <div class="mx-auto flex max-w-6xl flex-col gap-2 px-4 py-4 text-xs text-terminal-green/90 md:flex-row md:items-center md:justify-between md:px-8"> <span>Operador: MainDavis</span> <span> Estado: vigilancia activa </span> </div> </footer> </div> </body></html>