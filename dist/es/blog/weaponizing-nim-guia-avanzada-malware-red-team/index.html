<!DOCTYPE html><html lang="es"> <head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1"><meta name="color-scheme" content="dark"><link rel="preconnect" href="https://fonts.googleapis.com"><link rel="preconnect" href="https://fonts.gstatic.com" crossorigin><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=JetBrains+Mono:wght@300;400;500&display=swap"><link rel="icon" href="/favicon.svg"><link rel="canonical" href="https://maindavis.github.io/es/blog/weaponizing-nim-guia-avanzada-malware-red-team/"><title>Weaponizing Nim: Guia Avanzada de Desarrollo de Malware y Evasion para Red Teamers</title><meta name="title" content="Weaponizing Nim: Guia Avanzada de Desarrollo de Malware y Evasion para Red Teamers"><meta name="description" content="Guia avanzada para usar Nim en desarrollo ofensivo: syscalls, memoria, opsec y ejecucion sigilosa."><!-- Open Graph / Facebook --><meta property="og:type" content="article"><meta property="og:url" content="https://maindavis.github.io/es/blog/weaponizing-nim-guia-avanzada-malware-red-team/"><meta property="og:title" content="Weaponizing Nim: Guia Avanzada de Desarrollo de Malware y Evasion para Red Teamers"><meta property="og:description" content="Guia avanzada para usar Nim en desarrollo ofensivo: syscalls, memoria, opsec y ejecucion sigilosa."><meta property="og:image" content="https://maindavis.github.io/open-graph/es/weaponizing-nim-guia-avanzada-malware-red-team.png"><meta property="og:image:width" content="1200"><meta property="og:image:height" content="630"><!-- Twitter --><meta property="twitter:card" content="summary_large_image"><meta property="twitter:url" content="https://maindavis.github.io/es/blog/weaponizing-nim-guia-avanzada-malware-red-team/"><meta property="twitter:title" content="Weaponizing Nim: Guia Avanzada de Desarrollo de Malware y Evasion para Red Teamers"><meta property="twitter:description" content="Guia avanzada para usar Nim en desarrollo ofensivo: syscalls, memoria, opsec y ejecucion sigilosa."><meta property="twitter:image" content="https://maindavis.github.io/open-graph/es/weaponizing-nim-guia-avanzada-malware-red-team.png"><link rel="stylesheet" href="/_astro/about.B9y4o1ar.css">
<link rel="stylesheet" href="/_astro/index.BcZbEljn.css"></head> <body class="min-h-screen"> <style>astro-island,astro-slot,astro-static-slot{display:contents}</style><script>(()=>{var l=(o,t)=>{let i=async()=>{await(await o())()},e=typeof t.value=="object"?t.value:void 0,s={timeout:e==null?void 0:e.timeout};"requestIdleCallback"in window?window.requestIdleCallback(i,s):setTimeout(i,s.timeout||200)};(self.Astro||(self.Astro={})).idle=l;window.dispatchEvent(new Event("astro:idle"));})();;(()=>{var A=Object.defineProperty;var g=(i,o,a)=>o in i?A(i,o,{enumerable:!0,configurable:!0,writable:!0,value:a}):i[o]=a;var d=(i,o,a)=>g(i,typeof o!="symbol"?o+"":o,a);{let i={0:t=>m(t),1:t=>a(t),2:t=>new RegExp(t),3:t=>new Date(t),4:t=>new Map(a(t)),5:t=>new Set(a(t)),6:t=>BigInt(t),7:t=>new URL(t),8:t=>new Uint8Array(t),9:t=>new Uint16Array(t),10:t=>new Uint32Array(t),11:t=>1/0*t},o=t=>{let[l,e]=t;return l in i?i[l](e):void 0},a=t=>t.map(o),m=t=>typeof t!="object"||t===null?t:Object.fromEntries(Object.entries(t).map(([l,e])=>[l,o(e)]));class y extends HTMLElement{constructor(){super(...arguments);d(this,"Component");d(this,"hydrator");d(this,"hydrate",async()=>{var b;if(!this.hydrator||!this.isConnected)return;let e=(b=this.parentElement)==null?void 0:b.closest("astro-island[ssr]");if(e){e.addEventListener("astro:hydrate",this.hydrate,{once:!0});return}let c=this.querySelectorAll("astro-slot"),n={},h=this.querySelectorAll("template[data-astro-template]");for(let r of h){let s=r.closest(this.tagName);s!=null&&s.isSameNode(this)&&(n[r.getAttribute("data-astro-template")||"default"]=r.innerHTML,r.remove())}for(let r of c){let s=r.closest(this.tagName);s!=null&&s.isSameNode(this)&&(n[r.getAttribute("name")||"default"]=r.innerHTML)}let p;try{p=this.hasAttribute("props")?m(JSON.parse(this.getAttribute("props"))):{}}catch(r){let s=this.getAttribute("component-url")||"<unknown>",v=this.getAttribute("component-export");throw v&&(s+=` (export ${v})`),console.error(`[hydrate] Error parsing props for component ${s}`,this.getAttribute("props"),r),r}let u;await this.hydrator(this)(this.Component,p,n,{client:this.getAttribute("client")}),this.removeAttribute("ssr"),this.dispatchEvent(new CustomEvent("astro:hydrate"))});d(this,"unmount",()=>{this.isConnected||this.dispatchEvent(new CustomEvent("astro:unmount"))})}disconnectedCallback(){document.removeEventListener("astro:after-swap",this.unmount),document.addEventListener("astro:after-swap",this.unmount,{once:!0})}connectedCallback(){if(!this.hasAttribute("await-children")||document.readyState==="interactive"||document.readyState==="complete")this.childrenConnectedCallback();else{let e=()=>{document.removeEventListener("DOMContentLoaded",e),c.disconnect(),this.childrenConnectedCallback()},c=new MutationObserver(()=>{var n;((n=this.lastChild)==null?void 0:n.nodeType)===Node.COMMENT_NODE&&this.lastChild.nodeValue==="astro:end"&&(this.lastChild.remove(),e())});c.observe(this,{childList:!0}),document.addEventListener("DOMContentLoaded",e)}}async childrenConnectedCallback(){let e=this.getAttribute("before-hydration-url");e&&await import(e),this.start()}async start(){let e=JSON.parse(this.getAttribute("opts")),c=this.getAttribute("client");if(Astro[c]===void 0){window.addEventListener(`astro:${c}`,()=>this.start(),{once:!0});return}try{await Astro[c](async()=>{let n=this.getAttribute("renderer-url"),[h,{default:p}]=await Promise.all([import(this.getAttribute("component-url")),n?import(n):()=>()=>{}]),u=this.getAttribute("component-export")||"default";if(!u.includes("."))this.Component=h[u];else{this.Component=h;for(let f of u.split("."))this.Component=this.Component[f]}return this.hydrator=p,this.hydrate},e,this)}catch(n){console.error(`[astro-island] Error hydrating ${this.getAttribute("component-url")}`,n)}}attributeChangedCallback(){this.hydrate()}}d(y,"observedAttributes",["props"]),customElements.get("astro-island")||customElements.define("astro-island",y)}})();</script><astro-island uid="Z2c8VbI" prefix="r0" component-url="/_astro/MatrixRain.TxUs3SNa.js" component-export="default" renderer-url="/_astro/client.BuOr9PT5.js" props="{}" ssr="" client="idle" opts="{&quot;name&quot;:&quot;MatrixRain&quot;,&quot;value&quot;:true}" await-children=""><canvas class="pointer-events-none fixed inset-0 z-0 opacity-40" aria-hidden="true"></canvas><!--astro:end--></astro-island> <astro-island uid="Z1uoVBd" prefix="r1" component-url="/_astro/SearchModal.BgunQDqN.js" component-export="default" renderer-url="/_astro/client.BuOr9PT5.js" props="{&quot;locale&quot;:[0,&quot;es&quot;]}" ssr="" client="idle" opts="{&quot;name&quot;:&quot;SearchModal&quot;,&quot;value&quot;:true}"></astro-island> <div class="relative z-10 flex min-h-screen flex-col"> <header class="border-b border-terminal-border bg-terminal-black/90"> <div class="mx-auto flex max-w-6xl flex-col gap-3 px-4 py-4 md:flex-row md:items-center md:justify-between md:px-8"> <div class="flex items-center gap-3 text-xs uppercase tracking-[0.3em] text-terminal-muted/80"> <span class="h-2 w-2 rounded-full bg-terminal-green shadow-glow"></span> SESION_ACTIVA :: OPERACION_RED_TEAM </div> <div class="flex flex-wrap items-center gap-3"> <nav class="flex gap-2 text-sm"> <a href="/es" class="rounded-sm border px-3 py-1 transition border-terminal-border text-terminal-muted hover:border-terminal-green hover:shadow-glow-strong"> ~/inicio </a><a href="/es/blog" class="rounded-sm border px-3 py-1 transition border-terminal-green text-terminal-green text-glow"> ~/blog </a><a href="/es/arsenal" class="rounded-sm border px-3 py-1 transition border-terminal-border text-terminal-muted hover:border-terminal-green hover:shadow-glow-strong"> ~/arsenal </a><a href="/es/about" class="rounded-sm border px-3 py-1 transition border-terminal-border text-terminal-muted hover:border-terminal-green hover:shadow-glow-strong"> ~/perfil </a> </nav> <a href="/en/blog/weaponizing-nim-guia-avanzada-malware-red-team" class="rounded-sm border border-terminal-border px-3 py-1 text-xs uppercase tracking-[0.25em] text-terminal-muted transition hover:border-terminal-green hover:text-terminal-green"> EN </a> </div> </div> </header> <main class="flex-1 px-4 pb-12 pt-6 md:px-8">  <section class="mx-auto w-full max-w-5xl"> <div class="panel border-glow rounded-md px-5 py-4"> <h1 class="text-xl text-terminal-green text-glow">Weaponizing Nim: Guia Avanzada de Desarrollo de Malware y Evasion para Red Teamers</h1> <p class="mt-2 text-sm text-terminal-cyan/80">Guia avanzada para usar Nim en desarrollo ofensivo: syscalls, memoria, opsec y ejecucion sigilosa.</p> </div> <div class="mt-6">  <div class="post-hero border border-terminal-border/70 rounded-md"> <img src="/images/blog/offensive-nim.png" alt="Weaponizing Nim: Guia Avanzada de Desarrollo de Malware y Evasion para Red Teamers" loading="eager" decoding="async" fetchpriority="high"> </div> <article class="panel border-glow mt-6 rounded-md px-5 py-5 text-sm leading-relaxed text-terminal-light/90"> <h1 id="weaponizing-nim-guia-avanzada-de-desarrollo-de-malware-y-evasion-para-red-teamers">Weaponizing Nim: Guia Avanzada de Desarrollo de Malware y Evasion para Red Teamers</h1>
<p>Si has estado haciendo pentesting o Red Teaming ultimamente, habras notado un cambio en el ecosistema de herramientas. Durante anos, C# y PowerShell fueron los reyes, pero las firmas y el logging (AMSI, Script Block Logging) han hecho que sea cada vez mas dificil operar sin ser detectado. Aqui es donde entra Nim.</p>
<p>Recientemente, Nim se ha convertido en la opcion preferida para muchos desarrolladores de malware. Por que? Porque tiene una sintaxis amigable similar a Python, pero compila a ejecutables o DLLs nativos de Windows muy facilmente, sin depender de una maquina virtual pesada como lo hace Java o incluso Golang.</p>
<p>Este articulo no es una introduccion basica. Vamos a profundizar en como usar Nim para interactuar directamente con la API nativa de Windows (syscalls), como manejar la memoria de forma ofensiva y como evitar los errores comunes que cometen los novatos al intentar portar codigo de C a Nim.</p>
<hr>
<h2 id="configuracion-y-compilacion-para-opsec">Configuracion y Compilacion para OpSec</h2>
<p>Lo primero es olvidar Visual Studio. No necesitas ese IDE pesado. Un simple editor como VS Code y el compilador de Nim son suficientes. Una de las mayores ventajas de Nim es su capacidad de compilacion cruzada. Puedes compilar un binario de Windows desde Linux simplemente instalando el toolchain de MinGW y pasando un flag al compilador.</p>
<h3 id="flags-de-compilacion-criticos">Flags de Compilacion Criticos</h3>
<p>Para operaciones ofensivas, no puedes usar la configuracion por defecto. Necesitamos reducir el tamano y eliminar informacion de depuracion que los analistas de AV podrian usar para crear firmas. Segun la documentacion de Nim y la experiencia en campo, esta es la configuracion ganadora:</p>
<pre class="astro-code github-dark" style="background-color:#24292e;color:#e1e4e8; overflow-x: auto;" tabindex="0" data-language="bash"><code><span class="line"><span style="color:#B392F0">nim</span><span style="color:#9ECBFF"> c</span><span style="color:#79B8FF"> -d:danger</span><span style="color:#79B8FF"> -d:strip</span><span style="color:#79B8FF"> --opt:size</span><span style="color:#9ECBFF"> payload.nim</span></span>
<span class="line"></span></code></pre>
<ul>
<li><code>-d:danger</code>: Elimina todas las comprobaciones de tiempo de ejecucion (como limites de arrays). Es arriesgado, pero necesario para malware optimizado.</li>
<li><code>-d:strip</code>: Elimina simbolos.</li>
<li><code>--opt:size</code>: Optimiza el tamano del binario.</li>
</ul>
<hr>
<h2 id="de-win32-a-syscalls-evasion-de-hooks">De Win32 a Syscalls: Evasion de Hooks</h2>
<p>La mayoria del malware inyecta shellcode en memoria usando una secuencia de 4 metodos bien conocidos:</p>
<ol>
<li><code>OpenProcess</code>: Obtener un handle.</li>
<li><code>VirtualAllocEx</code>: Reservar memoria (RWX o RW).</li>
<li><code>WriteProcessMemory</code>: Escribir el payload.</li>
<li><code>CreateRemoteThread</code>: Ejecutar.</li>
</ol>
<p>El problema es que los EDRs y AVs colocan hooks (ganchos) en estas funciones a nivel de usuario (en <code>ntdll.dll</code> o <code>kernel32.dll</code>) para inspeccionar el flujo y redirigirlo a su motor de analisis.</p>
<p>Para evitar esto, usamos syscalls. Esto nos permite llamar a la Native API directamente, saltandonos los hooks del AV. En Nim, esto implica mapear nuestras llamadas a sus equivalentes nativos:</p>
<ul>
<li>Windows API -> Native API</li>
<li><code>OpenProcess</code> -> <code>NtOpenProcess</code></li>
<li><code>VirtualAllocEx</code> -> <code>NtAllocateVirtualMemory</code></li>
<li><code>WriteProcessMemory</code> -> <code>NtWriteVirtualMemory</code></li>
<li><code>CreateRemoteThread</code> -> <code>NtCreateThreadEx</code></li>
</ul>
<p>Al implementar un runner usando estos syscalls, he observado que soluciones como Windows Defender suelen ignorar el binario, especialmente si el payload no esta embebido en el ejecutable sino que se descarga por la red.</p>
<hr>
<h2 id="nim-a-bajo-nivel-punteros-memoria-y-trampas">Nim a Bajo Nivel: Punteros, Memoria y Trampas</h2>
<p>Aqui es donde la mayoria se atasca. Nim es un lenguaje de alto nivel, pero para malware necesitamos tocar memoria cruda.</p>
<h3 id="shellcode-array-o-secuencia">Shellcode: Array o Secuencia?</h3>
<p>Es recomendable usar <code>seq[byte]</code> (secuencia) en lugar de un array fijo. Las secuencias son dinamicas, lo que permite cargar payloads de tamano variable desde un archivo o red.</p>
<pre class="astro-code github-dark" style="background-color:#24292e;color:#e1e4e8; overflow-x: auto;" tabindex="0" data-language="nim"><code><span class="line"><span style="color:#F97583">let</span><span style="color:#E1E4E8"> shellcode</span><span style="color:#F97583">:</span><span style="color:#F97583"> seq</span><span style="color:#E1E4E8">[</span><span style="color:#F97583">byte</span><span style="color:#E1E4E8">] </span><span style="color:#F97583">=</span><span style="color:#F97583"> @</span><span style="color:#E1E4E8">[</span><span style="color:#F97583">byte</span><span style="color:#79B8FF"> 0x41</span><span style="color:#E1E4E8">, </span><span style="color:#79B8FF">0x41</span><span style="color:#E1E4E8">, </span><span style="color:#79B8FF">0x41</span><span style="color:#E1E4E8">]</span></span>
<span class="line"></span></code></pre>
<h3 id="el-problema-de-addr-vs-unsafeaddr">El problema de “addr” vs “unsafeAddr”</h3>
<p>Este es el punto mas critico. En C, obtener la direccion de un array es trivial. En Nim, no puedes usar simplemente la palabra clave <code>addr</code> para obtener la direccion directa de una secuencia <code>seq[byte]</code>. Debes usar <code>unsafeAddr</code> e indexar el primer elemento de la secuencia.</p>
<p>Si intentas pasar la secuencia directamente a una API de Windows como <code>VirtualAllocEx</code>, fallara. La forma correcta es:</p>
<pre class="astro-code github-dark" style="background-color:#24292e;color:#e1e4e8; overflow-x: auto;" tabindex="0" data-language="nim"><code><span class="line"><span style="color:#79B8FF">VirtualAllocEx</span><span style="color:#E1E4E8">(</span><span style="color:#F97583">...</span><span style="color:#E1E4E8">, </span><span style="color:#79B8FF">unsafeAddr </span><span style="color:#E1E4E8">shellcode[</span><span style="color:#79B8FF">0</span><span style="color:#E1E4E8">], </span><span style="color:#F97583">...</span><span style="color:#E1E4E8">)</span></span>
<span class="line"></span></code></pre>
<p>Es vital indexar la variable (<code>shellcode[0]</code>) para obtener el puntero al inicio de los datos en memoria.</p>
<h3 id="casteo-de-tipos-y-structs">Casteo de Tipos y Structs</h3>
<p>Windows requiere tipos especificos (<code>HANDLE</code>, <code>DWORD</code>, etc.). En Nim, puedes definir estos structs como objetos. Un detalle importante es el uso del pragma <code>{.pure.}</code> al definir el objeto para asegurar la compatibilidad de memoria. Ademas, al pasar structs inicializados a funciones (como <code>NtOpenProcess</code>), a veces es necesario pasarlos usando <code>unsafeAddr</code> en lugar de <code>addr</code>, ya que <code>addr</code> puede no comportarse como esperas con objetos gestionados por Nim.</p>
<p>Ejemplo de casteo rapido de un entero a <code>DWORD</code>:</p>
<pre class="astro-code github-dark" style="background-color:#24292e;color:#e1e4e8; overflow-x: auto;" tabindex="0" data-language="nim"><code><span class="line"><span style="color:#F97583">let</span><span style="color:#E1E4E8"> pid</span><span style="color:#F97583">:</span><span style="color:#F97583"> int</span><span style="color:#F97583"> =</span><span style="color:#79B8FF"> 1337</span></span>
<span class="line"><span style="color:#F97583">let</span><span style="color:#E1E4E8"> dPid</span><span style="color:#F97583">:</span><span style="color:#79B8FF"> DWORD</span><span style="color:#F97583"> =</span><span style="color:#F97583"> cast</span><span style="color:#E1E4E8">[</span><span style="color:#79B8FF">DWORD</span><span style="color:#E1E4E8">](pid)</span></span>
<span class="line"></span></code></pre>
<hr>
<h2 id="weaponizacion-real-un-runner-para-c2-slivercobalt-strike">Weaponizacion Real: Un Runner para C2 (Sliver/Cobalt Strike)</h2>
<p>Pongamos esto en practica. Un runner moderno no deberia llevar la shellcode dentro. Deberia descargarla.</p>
<p>He experimentado creando un modulo principal que recibe parametros (HTTP o SMB), descarga el payload, elimina el Vector de Inicializacion (IV) si viene de Sliver (los primeros 16 bytes), lo descifra (AES128 CBC) y lo inyecta.</p>
<h3 id="logica-de-descifrado-y-limpieza">Logica de Descifrado y Limpieza</h3>
<p>Si usas Sliver, el payload suele venir con un IV prepuesto. El codigo en Nim debe limpiar esto antes de descifrar:</p>
<pre class="astro-code github-dark" style="background-color:#24292e;color:#e1e4e8; overflow-x: auto;" tabindex="0" data-language="nim"><code><span class="line"><span style="color:#6A737D"># Si es Sliver, remover el IV de los primeros 16 bytes</span></span>
<span class="line"><span style="color:#F97583">if</span><span style="color:#F97583"> $</span><span style="color:#79B8FF">paramStr</span><span style="color:#E1E4E8">(</span><span style="color:#79B8FF">1</span><span style="color:#E1E4E8">) </span><span style="color:#F97583">==</span><span style="color:#9ECBFF"> "sliver"</span><span style="color:#F97583">:</span></span>
<span class="line"><span style="color:#F97583">  for</span><span style="color:#E1E4E8"> i </span><span style="color:#F97583">in</span><span style="color:#79B8FF"> 16</span><span style="color:#F97583"> ..&#x3C;</span><span style="color:#E1E4E8"> shellcode</span><span style="color:#F97583">.</span><span style="color:#E1E4E8">len</span><span style="color:#F97583">:</span></span>
<span class="line"><span style="color:#E1E4E8">    actual</span><span style="color:#F97583">.</span><span style="color:#79B8FF">add</span><span style="color:#E1E4E8">(shellcode[i])</span></span>
<span class="line"><span style="color:#E1E4E8">  shellcode </span><span style="color:#F97583">=</span><span style="color:#79B8FF"> decrypt</span><span style="color:#E1E4E8">(actual, key, iv)</span></span>
<span class="line"></span></code></pre>
<h3 id="inyeccion-segura">Inyeccion Segura</h3>
<p>Un consejo de OpSec: inyectar en procesos como <code>Notepad.exe</code> es una bandera roja masiva para Defender. Si haces eso, tu sesion morira rapido. Es mejor dejar que los syscalls creen su propio proceso o hilo, o inyectar en un proceso que tu mismo hayas generado y suspendido, evitando cruzar limites de procesos de sistema sensibles.</p>
<hr>
<h2 id="capacidades-avanzadas-el-repositorio-offensivenim">Capacidades Avanzadas: El Repositorio “OffensiveNim”</h2>
<p>Si quieres ir mas alla, el repositorio OffensiveNim de Byt3bl33d3r es la referencia obligada. Contiene snippets para casi cualquier tecnica moderna:</p>
<ul>
<li>Bypassing AMSI: Parchear la memoria del proceso para deshabilitar el escaneo de scripts.</li>
<li>Bypassing ETW: Deshabilitar Event Tracing for Windows para cegar la telemetria.</li>
<li>Unhooking ntdll: Recargar una copia limpia de ntdll desde el disco para eliminar los hooks del EDR.</li>
<li>Shellcode Injection: Varios metodos, incluyendo inyeccion clasica y syscalls directos.</li>
<li>CLR Hosting: Ejecutar assemblies de .NET directamente desde memoria sin tocar disco.</li>
</ul>
<hr>
<h2 id="conclusion">Conclusion</h2>
<p>Nim ofrece la elegancia de un lenguaje de scripting con la potencia de bajo nivel de C. Te permite construir herramientas ofensivas personalizadas rapidamente, manipular memoria con precision usando punteros (con cuidado con <code>unsafeAddr</code>) y compilar binarios que, por ahora, evaden muchas soluciones de seguridad por el simple hecho de no ser C# o PowerShell.</p>
<p>Si estas buscando actualizar tu arsenal de Red Team, portar tus cargadores y herramientas a Nim es el siguiente paso logico.</p> </article>  </div> </section>  </main> <footer class="border-t border-terminal-border bg-terminal-black/90"> <div class="mx-auto flex max-w-6xl flex-col gap-2 px-4 py-4 text-xs text-terminal-green/90 md:flex-row md:items-center md:justify-between md:px-8"> <span>Operador: MainDavis</span> <span> Estado: vigilancia activa </span> </div> </footer> </div> </body></html>